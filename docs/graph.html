
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Execution Engine &#8212; BlazingSQL v0.18 documentation</title>
    
  <link href="_static/css/theme.css" rel="stylesheet" />
  <link href="_static/css/index.101715efdecc9b59cb6e1ddfa685c31f.css" rel="stylesheet" />

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/basic.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/collapsible-lists/css/tree_view.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/getting_started.css" />
    <link rel="stylesheet" type="text/css" href="_static/css/blazingsql.css" />
    
  <link rel="preload" as="script" href="_static/js/index.d8bbf5861d671d414e1a.js">

    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/js/d3.v3.min.js"></script>
    <script src="_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script src="_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <link rel="shortcut icon" href="_static/blazingsql-icon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Documentation" href="api.html" />
    <link rel="prev" title="BlazingSQL Project Architecture" href="arch.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">


    
      
      <a class="navbar-brand" href="index.html">
        <img src="_static/blazingNotebooks_logo.png" class="logo" alt="logo">
      </a>
      
    

    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-menu" aria-controls="navbar-menu" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>

    
    <div id="navbar-menu" class="col-lg-9 collapse navbar-collapse">
      <ul id="navbar-main-elements" class="navbar-nav mr-auto">
        <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="arch.html">
  BlazingSQL Project Architecture
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="current reference internal nav-link" href="#">
  Execution Engine
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="api.html">
  API Documentation
 </a>
</li>

        
      </ul>

      <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
    </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    
  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
              
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#dag-of-kernels-and-caches">
   DAG of Kernels and Caches
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#relational-algebra">
     Relational algebra
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#sql">
   SQL
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#id1">
   Relational Algebra
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#physical-plan-single-gpu">
   Physical Plan Single GPU
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#physical-plan-multi-gpu">
   Physical Plan Multi GPU
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#column-table-wrappers">
     Column/Table Wrappers
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#blazingcolumn">
   BlazingColumn
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#blazingtable">
   BlazingTable
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#blazingtableview">
   BlazingTableView
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#kernels">
     Kernels
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#caches">
     Caches
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cachedata">
   CacheData
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#waitingqueue">
   WaitingQueue
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#cachemachine">
   CacheMachine
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#memory-management">
     Memory Management
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#blazingmemoryresource">
   BlazingMemoryResource
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#memorymonitor">
   MemoryMonitor
  </a>
 </li>
</ul>

</nav>



<div class="tocsection editthispage">
    <a href="https://github.com/blazingdb/blazingsql/edit/feedback/docsrc/source/graph.rst">
        <i class="fas fa-pencil-alt"></i> Edit this page
    </a>
</div>

              
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <div class="section" id="execution-engine">
<h1>Execution Engine<a class="headerlink" href="#execution-engine" title="Permalink to this headline">¶</a></h1>
<div class="section" id="dag-of-kernels-and-caches">
<h2>DAG of Kernels and Caches<a class="headerlink" href="#dag-of-kernels-and-caches" title="Permalink to this headline">¶</a></h2>
<a class="reference internal image-reference" href="_images/join_example.jpg"><img alt="A drawing of two nodes executing a Scan kernel, followed by a hash partition kernel that scatters data between the two nodes followed by a Join kernel." src="_images/join_example.jpg" style="width: 800px;" /></a>
<p>The above image gives a good overview of how we try to organize various operations that need to be performed on one or more dataframes or groups of files. Every kernel is connected to ever other kernel only through a cache. The purpose of the cache is to allow dataframes to be moved between different types of memory so that we can scale to problems larger than the different types of memory upon which we will be operating. All Kernels implement the <a class="reference external" href="api/library_root/classral_1_1cache_1_1kernel.html">Kernel</a> interface or one of their derived classes. A kernels purpose is to organize the flow and orchestration of performing complex distributed operations but it does not perform any of the execution itself. The final output of a DAG of kernels and caches thus arranged is a Cache itself.</p>
<p>When a user runs a query using <cite>bc.sql(query)</cite>, that query is sent to Apache Calcite
where it is parsed into relational algebra and then optimized. That optimized
algebra comes back into python and can always be viewed by calling
<cite>bc.explain(query)</cite>. The optimized relational algebra is sent via dask to each
of its workers along with sources of information (cudfs, or files).</p>
<p>On each worker the relational algebra is converted into a physical plan. Every
relational algebra step maps to 1 or more physical plan steps. That physical
plan is then used to construct an execution graph where every step in the
physical plan corresponds to a kernel.</p>
<div class="section" id="relational-algebra">
<h3>Relational algebra<a class="headerlink" href="#relational-algebra" title="Permalink to this headline">¶</a></h3>
<p>The BlazingSQL engine executes a relational algebra plan. This plan is initially
created by Apache Calcite, which in turn receives a SQL query.
The initial relational algebra is converted into an physical plan,
which is effectively a modified version of the original relational algebra plan,
wherein some of the relational algebra steps is expanded into multiple steps.</p>
</div>
</div>
<div class="section" id="sql">
<h2>SQL<a class="headerlink" href="#sql" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">select</span> <span class="n">o_custkey</span><span class="p">,</span> <span class="n">sum</span><span class="p">(</span><span class="n">o_totalprice</span><span class="p">)</span> <span class="n">from</span> <span class="n">orders</span> <span class="n">where</span> <span class="n">o_orderkey</span> <span class="o">&lt;</span> <span class="mi">10</span> <span class="n">group</span> <span class="n">by</span> <span class="n">o_custkey</span>
</pre></div>
</div>
</div>
<div class="section" id="id1">
<h2>Relational Algebra<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>LogicalProject(o_custkey=[$0], EXPR$1=[CASE(=($2, 0), null:DOUBLE, $1)])
  LogicalAggregate(group=[{0}], EXPR$1=[$SUM0($1)], agg#1=[COUNT($1)])
    LogicalProject(o_custkey=[$1], o_totalprice=[$2])
      BindableTableScan(table=[[main, orders]], filters=[[&lt;($0, 10)]], projects=[[0, 1, 3]], aliases=[[$f0, o_custkey, o_totalprice]])
</pre></div>
</div>
</div>
<div class="section" id="physical-plan-single-gpu">
<h2>Physical Plan Single GPU<a class="headerlink" href="#physical-plan-single-gpu" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>LogicalProject(o_custkey=[$0], EXPR$1=[CASE(=($2, 0), null:DOUBLE, $1)])
  MergeAggregate(group=[{0}], EXPR$1=[$SUM0($1)], agg#1=[COUNT($1)])
    ComputeAggregate(group=[{0}], EXPR$1=[$SUM0($1)], agg#1=[COUNT($1)])
      LogicalProject(o_custkey=[$1], o_totalprice=[$2])
        BindableTableScan(table=[[main, orders]], filters=[[&lt;($0, 10)]], projects=[[0, 1, 3]], aliases=[[$f0, o_custkey, o_totalprice]])
</pre></div>
</div>
</div>
<div class="section" id="physical-plan-multi-gpu">
<h2>Physical Plan Multi GPU<a class="headerlink" href="#physical-plan-multi-gpu" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>LogicalProject(o_custkey=[$0], EXPR$1=[CASE(=($2, 0), null:DOUBLE, $1)])
  MergeAggregate(group=[{0}], EXPR$1=[$SUM0($1)], agg#1=[COUNT($1)])
    DistributeAggregate(group=[{0}], EXPR$1=[$SUM0($1)], agg#1=[COUNT($1)])
      ComputeAggregate(group=[{0}], EXPR$1=[$SUM0($1)], agg#1=[COUNT($1)])
        LogicalProject(o_custkey=[$1], o_totalprice=[$2])
          BindableTableScan(table=[[main, orders]], filters=[[&lt;($0, 10)]], projects=[[0, 1, 3]], aliases=[[$f0, o_custkey, o_totalprice]])
</pre></div>
</div>
<p>The conversion of the relational algebra gets done by the function <code class="docutils literal notranslate"><span class="pre">transform_json_tree</span></code> in
<a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/PhysicalPlanGenerator.h">PhysicalPlanGenerator.h</a>.
This function gets called by <code class="docutils literal notranslate"><span class="pre">build_batch_graph</span></code>.</p>
<p>This new relational algebra plan is converted into a graph and each node in the graph becomes an execution kernel, while each edge becomes a <code class="docutils literal notranslate"><span class="pre">CacheMachine</span></code>.</p>
<p>The graph is created by <code class="docutils literal notranslate"><span class="pre">ral::batch::tree_processor</span></code> that has a function called <code class="docutils literal notranslate"><span class="pre">build_batch_graph</span></code>. This produces the actual graph object,
which is what contains all the execution kernels and CacheMachines. The graph has a function called <code class="docutils literal notranslate"><span class="pre">execute()</span></code> which is what actually starts the <code class="docutils literal notranslate"><span class="pre">run()</span></code> function of every execution kernel, each on its own thread.</p>
<div class="section" id="column-table-wrappers">
<h3>Column/Table Wrappers<a class="headerlink" href="#column-table-wrappers" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="blazingcolumn">
<h2>BlazingColumn<a class="headerlink" href="#blazingcolumn" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="blazingtable">
<h2>BlazingTable<a class="headerlink" href="#blazingtable" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="blazingtableview">
<h2>BlazingTableView<a class="headerlink" href="#blazingtableview" title="Permalink to this headline">¶</a></h2>
<p>Implements the same api as BlazingTable but wraps a <code class="docutils literal notranslate"><span class="pre">cudf::table_view</span></code> instead of
a vector of BlazingColumn.</p>
<div class="section" id="kernels">
<h3>Kernels<a class="headerlink" href="#kernels" title="Permalink to this headline">¶</a></h3>
<p><a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/taskflow/kernel.h">View in Github</a></p>
<p>Every step in the physical plan maps to exactly one kernel. Kernels implement the
interface defined above and are found in
<a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/BatchJoinProcessing.h">Join Kernels</a>,
<a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/BatchAggregationProcessing.h">Aggregation Kernels</a>
<a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/BatchOrderByProcessing.h">Order By Kernels</a>,
<a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/LogicalFilter.h">Filter Kernels</a>,
<a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/LogicalProject.h">Project Kernels</a>.</p>
<p>Each execution kernel is a Class which implements the
<a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/taskflow/kernel.h">kernel</a>
interface. All kernels have an input port and an output port. Each of which
contains a map of named CacheMachines. A kernel might write to multiple outputs
and may  receive input from multiple inputs but they are all contained within
the input and output ports.</p>
<p>Only in the TableScan and BindableTableScan kernels are the input ports not defined.
In these two cases the kernels themselves generate data either by passing
through a cudf or by reading files.</p>
<p>A kernel will have a <cite>run()</cite> function which starts its execution. It pulls data
from its input ports, operates on them, then sends the results to its output ports.
The ports are just maps of name to CachedMachine.</p>
<p>All kernels basically take data in batches from one or more input cache machines, do some work, and put results into an output cache machine.
Almost all work done is done in batches, and usually the way the kernels iterate through those batches is via some form of a <cite>DataSequencer</cite> or which there are 4 kinds
(these are defined in <a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/BatchProcessing.h">Join Kernels</a>):
BatchSequence
This is the standard data sequences that just pulls data from an input cache one batch at a time
BatchSequenceBypass
This data sequencer can pull data from a CacheMachine, but without decacheing the data. Serving as a bypass to take data from one input to an output without decacheing.
ExternalBatchColumnDataSequence
This data sequences connects a HostCacheMachine to a server receiving certain types of messages, so that basically the data sequences is effectively iterating through batches received from another node via out communication layer.</p>
</div>
<div class="section" id="caches">
<h3>Caches<a class="headerlink" href="#caches" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="cachedata">
<h2>CacheData<a class="headerlink" href="#cachedata" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/CacheMachine.h#L43">View in Github</a></p>
<p>There are different kinds of CacheData at the moment. GPU, CPU, LOCAL_FILE and
GPU_WITHMETADATA. The last of these being use exclusively in message routing.
Any implementer of CacheData must implement:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ral</span><span class="o">::</span><span class="n">frame</span><span class="o">::</span><span class="n">BlazingTable</span><span class="o">&gt;</span> <span class="n">decache</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The purpose of this class is that you can always call decache() on a CacheData
and get control of a BlazingTable that you own whose data is either moved in
the case of a GPU version, or brought into a GPU dataframe in the case it is a
non GPU version.</p>
<p>The LOCAL_FILE implementation uses ORC files as a temporary storage for data.</p>
</div>
<div class="section" id="waitingqueue">
<h2>WaitingQueue<a class="headerlink" href="#waitingqueue" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/CacheMachine.h#L167">View in Github</a></p>
<p>Stores CacheData for us. Every CacheMachine has a WaitingQueue whose purpose it
is to hold the CacheData until they are needed by a kernel. Many of its methods
are waiting operations of the nature get_or_wait() which will wait on a
condition variable until something can actually be pulled from the WaitingQueue.</p>
</div>
<div class="section" id="cachemachine">
<h2>CacheMachine<a class="headerlink" href="#cachemachine" title="Permalink to this headline">¶</a></h2>
<p>Cache Machines are an abstraction built on top of WaitingQueues that manage the
logic of knowing when a dataframe should stay on the gpu or be moved to RAM or
disk.</p>
<p>When you add data into a CacheMachine, it checks the memory consumption
of the node by asking the memory resource (see below). If the consumption is below a certain
threshold, then the data is maintained in GPU memory. It is converted into a
GPUCacheData and added to the CacheMachine. If consumption is above the device
memory threshold, then it checks the next tier in the CacheMachine, the CPU
cache. It checks the memory consumption of the CPU memory resource. If it is
below that threshold, it converts the BlazingTable into a CPUCacheData, where it
copied all the data to host. If the CPU memory consumption is above a certain
threshold, then it goes into the next tier, the Disk Cache. For the disk cache,
the data is placed in an ORC file and a CacheDataLocalFile is created to keep track of it.</p>
<p>Aside from the standard CacheMachine, there are two specialty types: HostCacheMachine and ConcatenatingCacheMachine. The HostCacheMachine is only used to place data received by other nodes and the ConcatenatingCacheMachine is used as the output of TableScans. The ConcatenatingCacheMachine will concatenate batches so that the resulting batch is not too small. This is configurable, and its done to increase performance. Operating on really small batches can be detrimental to performance.</p>
<p>CacheMachines and CacheData are defined <a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/execution_graph/logic_controllers/CacheMachine.h">CacheMachine.h</a></p>
<div class="section" id="memory-management">
<h3>Memory Management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="blazingmemoryresource">
<h2>BlazingMemoryResource<a class="headerlink" href="#blazingmemoryresource" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/bmr/BlazingMemoryResource.h">View in Github</a></p>
<p>BlazingSQL has a <cite>BlazingMemoryResource</cite> interface that it uses for tracking memory consumption.
There are three implementations <cite>blazing_device_memory_resource</cite>, <cite>blazing_host_memory_resource</cite> and <cite>blazing_disk_memory_resource</cite>
to manange to keep track of GPU, HOST and DISK memory consumption.</p>
<p>The <cite>blazing_device_memory_resource</cite> internally has a <cite>internal_blazing_device_memory_resource</cite> which implements the <cite>rmm::mr::device_memory_resource</cite> interface.
When a BlazingContext() is first created it will create a new <cite>internal_blazing_device_memory_resource</cite> and set it as the default resource using <cite>rmm::mr::set_current_device_resource</cite>.</p>
<p>What form the <cite>internal_blazing_device_memory_resource</cite> takes is dependent on what parameters are passed to <cite>BlazingContext()</cite> parameters <strong>allocator</strong> and <strong>pool</strong>.
Different allocators settings can make the allocator use different underlying RMM allocator types. If the allocator is set to <strong>existing</strong>, then it will take the current
default allocator that has been set and wrap it with <cite>internal_blazing_device_memory_resource</cite></p>
<p>The <cite>blazing_host_memory_resource</cite> and <cite>blazing_disk_memory_resource</cite> only track allocations and deallocations when BSQL caches and decaches data in the CacheMachines.</p>
<p>Whenever data enters a CacheMachine, it will check the memory consumption of the three <cite>BlazingMemoryResource</cite> to see where the CacheData should reside. This is one mechanism
employed by BSQL to manage memory consumption.</p>
</div>
<div class="section" id="memorymonitor">
<h2>MemoryMonitor<a class="headerlink" href="#memorymonitor" title="Permalink to this headline">¶</a></h2>
<p><a class="reference external" href="https://github.com/BlazingDB/blazingsql/blob/branch-0.19//engine/src/bmr/MemoryMonitor.h">View in Github</a></p>
<p>BlazingSQL has a <cite>MemoryMonitor</cite> class that it instantiates for every query that is run. This MemoryMonitor will wake up every 50ms (configurable by MEMORY_MONITOR_PERIOD)
and check the GPU memory consumption as tracked by <cite>blazing_device_memory_resource</cite>. If memory consumption is too high, it will traverse the execution graph from the last node (final output)
to the first nodes (TableScans) downgrading CacheData as it can, to bring GPU memory consumption underneath its threshold. Downgrading CacheData means, taking a GPU CacheData and moving
the data to Host or Disk.</p>
<p>The <cite>MemoryMonitor</cite> helps ensure that memory GPU consumption does not get too high and therefore helps prevent OOM errors.</p>
</div>
</div>


              </div>
              
              
              <div class='prev-next-bottom'>
                
    <a class='left-prev' id="prev-link" href="arch.html" title="previous page">BlazingSQL Project Architecture</a>
    <a class='right-next' id="next-link" href="api.html" title="next page">API Documentation</a>

              </div>
              
          </main>
          

      </div>
    </div>

    
  <script src="_static/js/index.d8bbf5861d671d414e1a.js"></script>


    <footer class="footer mt-5 mt-md-0">
  <div class="container">
    <p>
          &copy; Copyright 2020, BlazingDB, Inc..<br/>
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 3.5.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>