
.. _program_listing_file_engine_src_execution_graph_logic_controllers_taskflow_distributing_kernel.h:

Program Listing for File distributing_kernel.h
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file_engine_src_execution_graph_logic_controllers_taskflow_distributing_kernel.h>` (``engine/src/execution_graph/logic_controllers/taskflow/distributing_kernel.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <atomic>
   #include <map>
   #include <vector>
   #include "distribution/primitives.h"
   #include "execution_graph/logic_controllers/CacheMachine.h"
   #include <execution_graph/Context.h>
   #include "kernel.h"
   
   namespace ral {
   namespace cache {
   
   using Context = blazingdb::manager::Context;
   
   class distributing_kernel : public kernel {
       public:
       distributing_kernel(std::size_t kernel_id,
           std::string expr,
           std::shared_ptr<Context> context,
           kernel_type kernel_type_id);
   
       std::string kernel_name() { return "distributing_kernel";}
   
       void set_number_of_message_trackers(std::size_t num_message_trackers);
   
       void send_message(std::unique_ptr<ral::frame::BlazingTable> table,
           bool specific_cache,
           std::string cache_id,
           std::vector<std::string> target_ids,
           std::string message_id_prefix = "",
           bool always_add = false,
           bool wait_for = false,
           std::size_t message_tracker_idx = 0,
           ral::cache::MetadataDictionary extra_metadata = {});
   
       void scatter(std::vector<ral::frame::BlazingTableView> partitions,
           ral::cache::CacheMachine* output,
           std::string message_id_prefix,
           std::string cache_id,
           std::size_t message_tracker_idx = 0);
   
       void scatterParts(std::vector<ral::distribution::NodeColumnView> partitions,
           std::string message_id_prefix,
           std::vector<int32_t> part_ids);
   
       void broadcast(std::unique_ptr<ral::frame::BlazingTable> table,
           ral::cache::CacheMachine* output,
           std::string message_id_prefix,
           std::string cache_id,
           std::size_t message_tracker_idx = 0,
           bool always_add = false);
   
   
       void send_total_partition_counts(
           std::string message_id_prefix,
           std::string cache_id,
           std::size_t message_tracker_idx = 0);
   
       int get_total_partition_counts(std::size_t message_tracker_idx = 0);
   
       void increment_node_count(std::string node_id, std::size_t message_tracker_idx = 0);
   
       virtual ~distributing_kernel() = default;
   
       private:
           const blazingdb::transport::Node& node; 
           std::vector<std::map<std::string, std::atomic<size_t>>> node_count; 
           std::vector<std::vector<std::string>> messages_to_wait_for; 
           std::mutex messages_to_wait_for_mutex;
   };
   
   }  // namespace cache
   }  // namespace ral
