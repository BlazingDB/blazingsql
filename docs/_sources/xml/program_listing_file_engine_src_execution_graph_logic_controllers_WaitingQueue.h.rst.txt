
.. _program_listing_file_engine_src_execution_graph_logic_controllers_WaitingQueue.h:

Program Listing for File WaitingQueue.h
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file_engine_src_execution_graph_logic_controllers_WaitingQueue.h>` (``engine/src/execution_graph/logic_controllers/WaitingQueue.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <atomic>
   #include <deque>
   #include <memory>
   #include <condition_variable>
   #include <mutex>
   #include <string>
   #include <vector>
   #include <map>
   
   #include <spdlog/spdlog.h>
   #include <exception>
   
   using namespace std::chrono_literals;
   
   namespace ral {
   namespace cache {
   
   using Context = blazingdb::manager::Context;
   using namespace fmt::literals;
   
   
   
   template <typename message_ptr>
   class WaitingQueue {
   public:
   
       WaitingQueue(std::string queue_name, int timeout = 60000, bool log_timeout = true) : 
           queue_name(queue_name), finished{false}, timeout(timeout), log_timeout(log_timeout) {}
   
       ~WaitingQueue() = default;
   
       WaitingQueue(WaitingQueue &&) = delete;
       WaitingQueue(const WaitingQueue &) = delete;
       WaitingQueue & operator=(WaitingQueue &&) = delete;
       WaitingQueue & operator=(const WaitingQueue &) = delete;
   
       void put(message_ptr item) {
           std::unique_lock<std::mutex> lock(mutex_);
           putWaitingQueue(std::move(item));
           processed++;
           condition_variable_.notify_all();
       }
   
       int processed_parts(){
           std::unique_lock<std::mutex> lock(mutex_);
           return processed;
       }
   
       void finish() {
           std::unique_lock<std::mutex> lock(mutex_);
           this->finished = true;
           condition_variable_.notify_all();
       }
   
       bool is_finished() {
           return this->finished.load(std::memory_order_seq_cst);
       }
   
       void wait_for_count(int count){
   
           CodeTimer blazing_timer;
           std::unique_lock<std::mutex> lock(mutex_);
           while(!condition_variable_.wait_for(lock, timeout*1ms, [&, this] {
                   bool done_waiting = count == this->processed;
                   if (!done_waiting && blazing_timer.elapsed_time() > 59000 && this->log_timeout){
                       std::shared_ptr<spdlog::logger> logger = spdlog::get("batch_logger");
                       if(logger) {
                           logger->warn("|||{info}|{duration}||||",
                                               "info"_a="WaitingQueue " + this->queue_name + " wait_for_count timed out. count = " + std::to_string(count) + " processed = " + std::to_string(this->processed),
                                               "duration"_a=blazing_timer.elapsed_time());
                       }
                   }
                   if (count < this->processed){
                       throw std::runtime_error("WaitingQueue::wait_for_count " + this->queue_name + " encountered " + std::to_string(this->processed) + " when expecting " + std::to_string(count));
                   }
                   return done_waiting;
               })){}
   
   
           // condition_variable_.wait(lock, [&, this] () {
           //  if (count < this->processed){
           //      throw std::runtime_error("WaitingQueue::wait_for_count " + this->queue_name + " encountered " + std::to_string(this->processed) + " when expecting " + std::to_string(count));
           //  }
           //  return count == this->processed;
           // });
       }
   
       message_ptr pop_or_wait() {
   
           CodeTimer blazing_timer;
           std::unique_lock<std::mutex> lock(mutex_);
           while(!condition_variable_.wait_for(lock, timeout*1ms, [&, this] {
                   bool done_waiting = this->finished.load(std::memory_order_seq_cst) or !this->empty();
                   if (!done_waiting && blazing_timer.elapsed_time() > 59000 && this->log_timeout){
                       std::shared_ptr<spdlog::logger> logger = spdlog::get("batch_logger");
                       if(logger) {
                           logger->warn("|||{info}|{duration}||||",
                                               "info"_a="WaitingQueue " + this->queue_name + " pop_or_wait timed out",
                                               "duration"_a=blazing_timer.elapsed_time());
                       }
                   }
                   return done_waiting;
               })){}
   
           // condition_variable_.wait(lock,[&, this] {
           //      return this->finished.load(std::memory_order_seq_cst) or !this->empty();
           // });
           if(this->message_queue_.size() == 0) {
               return nullptr;
           }
           auto data = std::move(this->message_queue_.front());
           this->message_queue_.pop_front();
           return std::move(data);
       }
   
       message_ptr pop_back() {
   
           std::lock_guard<std::mutex> lock(mutex_);
           if(this->message_queue_.size() == 0) {
               return nullptr;
           }
           auto data = std::move(this->message_queue_.back());
           this->message_queue_.pop_back();
           return std::move(data);
       }
   
       bool wait_for_next() {
           CodeTimer blazing_timer;
           std::unique_lock<std::mutex> lock(mutex_);
           while(!condition_variable_.wait_for(lock, timeout*1ms, [&, this] {
                   bool done_waiting = this->finished.load(std::memory_order_seq_cst) or !this->empty();
                   if (!done_waiting && blazing_timer.elapsed_time() > 59000 && this->log_timeout){
                       std::shared_ptr<spdlog::logger> logger = spdlog::get("batch_logger");
                       if(logger) {
                           logger->warn("|||{info}|{duration}||||",
                                               "info"_a="WaitingQueue " + this->queue_name + " wait_for_next timed out",
                                               "duration"_a=blazing_timer.elapsed_time());
                       }
                   }
                   return done_waiting;
               })){}
   
           if(this->empty()) {
               return false;
           }
           return true;
       }
       bool has_next_now() {
           std::unique_lock<std::mutex> lock(mutex_);
           return !this->empty();
       }
   
       void wait_until_finished() {
           CodeTimer blazing_timer;
           std::unique_lock<std::mutex> lock(mutex_);
           while(!condition_variable_.wait_for(lock, timeout*1ms, [&blazing_timer, this] {
                   bool done_waiting = this->finished.load(std::memory_order_seq_cst);
                   if (!done_waiting && blazing_timer.elapsed_time() > 59000 && this->log_timeout){
                       std::shared_ptr<spdlog::logger> logger = spdlog::get("batch_logger");
                       if(logger) {
                          logger->warn("|||{info}|{duration}||||",
                                              "info"_a="WaitingQueue " + this->queue_name + " wait_until_finished timed out",
                                              "duration"_a=blazing_timer.elapsed_time());
                       }
                   }
                   return done_waiting;
               })){}
       }
   
       void wait_until_num_bytes(size_t num_bytes) {
           CodeTimer blazing_timer;
           std::unique_lock<std::mutex> lock(mutex_);
           while(!condition_variable_.wait_for(lock, timeout*1ms, [&blazing_timer, num_bytes, this] {
                   bool done_waiting = this->finished.load(std::memory_order_seq_cst);
                   size_t total_bytes = 0;
                   if (!done_waiting) {                    
                       for (auto & message : message_queue_){
                           total_bytes += message->get_data().sizeInBytes();
                       }
                       done_waiting = total_bytes > num_bytes;
                   }
                   if (!done_waiting && blazing_timer.elapsed_time() > 59000 && this->log_timeout){
                       std::shared_ptr<spdlog::logger> logger = spdlog::get("batch_logger");
                       if(logger) {
                           logger->warn("|||{info}|{duration}||||",
                                               "info"_a="WaitingQueue " + this->queue_name + " wait_until_num_bytes timed out num_bytes wanted: " + std::to_string(num_bytes) + " total_bytes: " + std::to_string(total_bytes),
                                               "duration"_a=blazing_timer.elapsed_time());
                       }
                   }
                   return done_waiting;
               })){}
       }
   
       size_t get_next_size_in_bytes(){
           std::unique_lock<std::mutex> lock(mutex_);
           if (message_queue_.size() > 0){
               return message_queue_[0]->get_data().sizeInBytes();
           } else {
               return 0;
           }
       }
   
       message_ptr get_or_wait(std::string message_id) {
           CodeTimer blazing_timer;
           std::unique_lock<std::mutex> lock(mutex_);
           while(!condition_variable_.wait_for(lock, timeout*1ms, [message_id, &blazing_timer, this] {
                   auto result = std::any_of(this->message_queue_.cbegin(),
                               this->message_queue_.cend(), [&](auto &e) {
                                   return e->get_message_id() == message_id;
                               });
                   bool done_waiting = this->finished.load(std::memory_order_seq_cst) or result;
                   if (!done_waiting && blazing_timer.elapsed_time() > 59000 && this->log_timeout){
                       std::shared_ptr<spdlog::logger> logger = spdlog::get("batch_logger");
                       if(logger) {
                           logger->warn("|||{info}|{duration}|message_id|{message_id}||",
                                               "info"_a="WaitingQueue " + this->queue_name + " get_or_wait timed out",
                                               "duration"_a=blazing_timer.elapsed_time(),
                                               "message_id"_a=message_id);
                       }
                   }
                   return done_waiting;
               })){
   
               }
           if(this->message_queue_.size() == 0) {
               return nullptr;
           }
           while (true){
               auto data = this->pop_unsafe();
               if (data->get_message_id() == message_id){
                   return std::move(data);
               } else {
                   putWaitingQueue(std::move(data));
               }
           }
       }
   
       message_ptr pop_unsafe() {
           if(this->message_queue_.size() == 0) {
               return nullptr;
           }
           auto data = std::move(this->message_queue_.front());
           this->message_queue_.pop_front();
           return std::move(data);
       }
   
       std::vector<message_ptr> get_all(){
           std::unique_lock<std::mutex> lock(mutex_);
           return get_all_unsafe();
       }
   
       std::vector<std::string> get_all_message_ids(){
           std::unique_lock<std::mutex> lock(mutex_);
           std::vector<std::string> message_ids;
           message_ids.reserve(message_queue_.size());
           for(message_ptr & it : message_queue_) {
               message_ids.push_back(it->get_message_id());
           }
           return message_ids;
       }
   
       std::vector<message_ptr> get_all_or_wait() {
           CodeTimer blazing_timer;
           std::unique_lock<std::mutex> lock(mutex_);
           while(!condition_variable_.wait_for(lock, timeout*1ms,  [&blazing_timer, this] {
                   bool done_waiting = this->finished.load(std::memory_order_seq_cst);
                   if (!done_waiting && blazing_timer.elapsed_time() > 59000 && this->log_timeout){
                       std::shared_ptr<spdlog::logger> logger = spdlog::get("batch_logger");
                       if(logger) {
                           logger->warn("|||{info}|{duration}||||",
                                               "info"_a="WaitingQueue " + this->queue_name + " get_all_or_wait timed out",
                                               "duration"_a=blazing_timer.elapsed_time());
                       }
                   }
                   return done_waiting;
               })){}
           return get_all_unsafe();
       }
   
       std::unique_lock<std::mutex> lock(){
           std::unique_lock<std::mutex> lock(mutex_);
           return std::move(lock);
       }
   
       std::vector<message_ptr> get_all_unsafe() {
           std::vector<message_ptr> messages;
           for(message_ptr & it : message_queue_) {
               messages.emplace_back(std::move(it));
           }
           message_queue_.clear();
           return messages;
       }
   
       void put_all_unsafe(std::vector<message_ptr> messages) {
           for(size_t i = 0; i < messages.size(); i++) {
               putWaitingQueue(std::move(messages[i]));
           }
       }
   
   
       void put_all(std::vector<message_ptr> messages){
           std::unique_lock<std::mutex> lock(mutex_);
           put_all_unsafe(std::move(messages));
           processed += messages.size();
           condition_variable_.notify_all();
       }
   private:
       bool empty() {
           return this->message_queue_.size() == 0;
       }
       void putWaitingQueue(message_ptr item) { message_queue_.emplace_back(std::move(item)); }
   
   private:
       std::mutex mutex_; 
       std::deque<message_ptr> message_queue_; 
       std::atomic<bool> finished; 
       std::condition_variable condition_variable_; 
       int processed = 0; 
       int timeout; 
       std::string queue_name;
       bool log_timeout; 
   };
   
   }  // namespace cache
   
   
   } // namespace ral
