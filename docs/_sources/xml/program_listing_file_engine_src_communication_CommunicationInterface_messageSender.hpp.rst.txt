
.. _program_listing_file_engine_src_communication_CommunicationInterface_messageSender.hpp:

Program Listing for File messageSender.hpp
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file_engine_src_communication_CommunicationInterface_messageSender.hpp>` (``engine/src/communication/CommunicationInterface/messageSender.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <transport/ColumnTransport.h>
   #include <memory>
   #include <rmm/device_buffer.hpp>
   #include <utility>
   #include <Util/StringUtil.h>
   
   #include "ExceptionHandling/BlazingThread.h"
   #include "node.hpp"
   #include "execution_graph/logic_controllers/CacheMachine.h"
   #include "utilities/ctpl_stl.h"
   #include "protocols.hpp"
   
   namespace comm {
   
   class message_sender {
   public:
   
       static message_sender * get_instance();
       message_sender(std::shared_ptr<ral::cache::CacheMachine> output_cache,
           const std::map<std::string, node> & node_address_map,
           int num_threads,
           ucp_context_h context,
           ucp_worker_h origin,
           int ral_id,
           comm::blazing_protocol protocol,
           bool require_acknowledge);
   
       static void initialize_instance(std::shared_ptr<ral::cache::CacheMachine> output_cache,
           std::map<std::string, node> node_address_map,
           int num_threads,
           ucp_context_h context,
           ucp_worker_h origin_node,
           int ral_id,
           comm::blazing_protocol protocol,
           bool require_acknowledge);
   
       std::shared_ptr<ral::cache::CacheMachine> get_output_cache(){
           return output_cache;
       }
       
       void run_polling();
   private:
       static message_sender * instance;
   
       ctpl::thread_pool<BlazingThread> pool;
       std::shared_ptr<ral::cache::CacheMachine> output_cache;
       std::map<std::string, node> node_address_map;
       blazing_protocol protocol;
       ucp_worker_h origin;
       size_t request_size;
       int ral_id;
       bool polling_started{false};
       bool require_acknowledge;
   };
   
   }  // namespace comm
