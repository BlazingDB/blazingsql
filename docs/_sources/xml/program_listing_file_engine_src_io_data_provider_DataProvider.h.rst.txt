
.. _program_listing_file_engine_src_io_data_provider_DataProvider.h:

Program Listing for File DataProvider.h
=======================================

|exhale_lsh| :ref:`Return to documentation for file <file_engine_src_io_data_provider_DataProvider.h>` (``engine/src/io/data_provider/DataProvider.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
    * DataProvider.h
    *
    *  Created on: Nov 29, 2018
    *      Author: felipe
    */
   
   #ifndef DATAPROVIDER_H_
   #define DATAPROVIDER_H_
   
   #include <spdlog/spdlog.h>
   #include <spdlog/async.h>
   #include <spdlog/sinks/basic_file_sink.h>
   #include <spdlog/sinks/stdout_color_sinks.h>
   
   #include <arrow/io/interfaces.h>
   
   #pragma GCC diagnostic ignored "-Wunknown-pragmas"
   //#include <cudf/cudf.h>
   #include <cudf/scalar/scalar.hpp>
   #include <cudf/scalar/scalar_factories.hpp>
   #include <cudf/types.hpp>
   #include <cudf/utilities/type_dispatcher.hpp>
   #include <cudf/scalar/scalar_device_view.cuh>
   #pragma GCC diagnostic pop
   
   #include <map>
   #include <memory>
   #include <vector>
   
   #include <blazingdb/io/FileSystem/Uri.h>
   #include "execution_graph/logic_controllers/LogicPrimitives.h"
   
   namespace ral {
   namespace io {
   
   struct data_handle {
       std::shared_ptr<arrow::io::RandomAccessFile> file_handle;
       std::map<std::string, std::string> column_values;  // allows us to add hive values
       Uri uri;                                          // in case the data was loaded from a file
       frame::BlazingTableView table_view;
       data_handle(){}
       data_handle(
           std::shared_ptr<arrow::io::RandomAccessFile> file_handle,
           std::map<std::string, std::string> column_values,
           Uri uri,                                         
           frame::BlazingTableView table_view) 
       : file_handle(file_handle), column_values(column_values), uri(uri), table_view(table_view) {
   
       }
   
       bool is_valid(){
           return file_handle != nullptr || !uri.isEmpty() ;
       }
   };
   
   class data_provider {
   public:
   
       virtual std::shared_ptr<data_provider> clone() = 0; 
   
       virtual bool has_next() = 0;
   
       virtual void reset() = 0;
   
       virtual data_handle get_next(bool open_file = true) = 0;
   
       virtual std::vector<data_handle> get_some(std::size_t num_files, bool open_file = true) = 0;
   
       virtual void close_file_handles() = 0;
   
       virtual size_t get_num_handles() = 0;
   
   
   };
   
   } /* namespace io */
   } /* namespace ral */
   
   #endif /* DATAPROVIDER_H_ */
