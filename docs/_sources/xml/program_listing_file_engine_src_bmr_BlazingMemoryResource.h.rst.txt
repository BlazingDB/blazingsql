
.. _program_listing_file_engine_src_bmr_BlazingMemoryResource.h:

Program Listing for File BlazingMemoryResource.h
================================================

|exhale_lsh| :ref:`Return to documentation for file <file_engine_src_bmr_BlazingMemoryResource.h>` (``engine/src/bmr/BlazingMemoryResource.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once 
   
   #include <cassert>
   #include <atomic>
   #include <set>
   
   #include <cuda_runtime_api.h>
   
   #pragma GCC diagnostic ignored "-Wreorder"
   #include <rmm/cuda_stream_view.hpp>
   #include <rmm/mr/device/device_memory_resource.hpp>
   #include <rmm/mr/device/owning_wrapper.hpp>
   #include <rmm/mr/device/cuda_memory_resource.hpp>
   #include <rmm/mr/device/managed_memory_resource.hpp>
   #include <rmm/mr/device/pool_memory_resource.hpp>
   #include <rmm/mr/device/arena_memory_resource.hpp>
   #include <rmm/mr/device/logging_resource_adaptor.hpp>
   #include <rmm/mr/device/per_device_resource.hpp>
   #pragma GCC diagnostic pop
   
   #include "config/GPUManager.cuh"
   
   #include <sys/sysinfo.h>
   #include <sys/statvfs.h>
   
   class BlazingMemoryResource {
   public:
       virtual size_t get_from_driver_used_memory() = 0 ; // driver.get_available_memory()
       virtual size_t get_memory_limit() = 0 ; // memory_limite = total_memory * threshold
       virtual size_t get_memory_used() = 0 ; // atomic 
       virtual size_t get_total_memory() = 0 ; // total_memory
   };
   
   class internal_blazing_device_memory_resource : public rmm::mr::device_memory_resource { 
   public:
       // TODO: use another constructor for memory in bytes
   
       internal_blazing_device_memory_resource(std::string allocation_mode,
                                               std::size_t initial_pool_size,
                                               std::size_t maximum_pool_size,
                                               std::string allocator_logging_file = "",
                                               float custom_threshold = 0.95);
   
       virtual ~internal_blazing_device_memory_resource() = default;
   
       size_t get_memory_used();
       size_t get_max_memory_used();
       size_t get_from_driver_used_memory();
       size_t get_total_memory();
       size_t get_memory_limit();
       std::string get_type();
       bool supports_streams() const noexcept override;
       bool supports_get_mem_info() const noexcept override;
       std::string get_full_memory_summary();
       void reset_max_memory_used(size_t to = 0) noexcept;
   
   private:
       void* do_allocate(size_t bytes, rmm::cuda_stream_view stream) override;
       void do_deallocate(void* p, size_t bytes, rmm::cuda_stream_view stream) override;
       bool do_is_equal(device_memory_resource const& other) const noexcept override;
       std::pair<size_t, size_t> do_get_mem_info(rmm::cuda_stream_view stream) const override;
   
       size_t total_memory_size;
       size_t memory_limit;
       std::atomic<size_t> used_memory;
       std::atomic<size_t> max_used_memory;
       std::shared_ptr<rmm::mr::device_memory_resource> memory_resource_owner;
       rmm::mr::device_memory_resource * memory_resource;
       std::unique_ptr<rmm::mr::logging_resource_adaptor<rmm::mr::device_memory_resource>> logging_adaptor;
       std::string type;
   };
   
   // forward declaration
   typedef struct CUstream_st *cudaStream_t;
   
   class blazing_device_memory_resource : public BlazingMemoryResource {
   public:
       static blazing_device_memory_resource& getInstance() {
           // Myers' singleton. Thread safe and unique. Note: C++11 required.
           static blazing_device_memory_resource instance;
           return instance;
       }
   
       size_t get_memory_used();
   
       size_t get_max_memory_used();
   
       size_t get_total_memory();
   
       size_t get_from_driver_used_memory();
   
       size_t get_memory_limit();
   
       std::string get_type();
   
       std::string get_full_memory_summary();
       
       void reset_max_memory_used(size_t to = 0);
   
       void initialize(std::string allocation_mode,
                       std::size_t initial_pool_size,
                       std::size_t maximum_pool_size,
                       std::string allocator_logging_file,
                       float device_mem_resouce_consumption_thresh);
   
       void finalize();
   
       bool isInitialized();
   
   private:
       blazing_device_memory_resource() = default;
       ~blazing_device_memory_resource() = default;
       blazing_device_memory_resource(const blazing_device_memory_resource&) = delete;
       blazing_device_memory_resource& operator=(const blazing_device_memory_resource&) = delete;
       std::mutex manager_mutex;
       std::set<cudaStream_t> registered_streams;
   
       bool is_initialized{false};
   
       std::unique_ptr<internal_blazing_device_memory_resource> initialized_resource{};
   };
   
   class internal_blazing_host_memory_resource{
   public:
       // TODO: percy,cordova. Improve the design of get memory in real time 
       internal_blazing_host_memory_resource(float custom_threshold);
   
       virtual ~internal_blazing_host_memory_resource() = default;
   
       void allocate(std::size_t bytes);
   
       void deallocate(std::size_t bytes);
   
       size_t get_from_driver_used_memory();
   
       size_t get_memory_used();
   
       size_t get_total_memory();
   
       size_t get_memory_limit();
   
   private:
       size_t memory_limit;
       size_t total_memory_size;
       std::atomic<std::size_t> used_memory_size;
   };
   
   class blazing_host_memory_resource : public BlazingMemoryResource {
   public:
       static blazing_host_memory_resource& getInstance() {
           // Myers' singleton. Thread safe and unique. Note: C++11 required.
           static blazing_host_memory_resource instance;
           return instance;
       }
   
       size_t get_memory_used() override;
   
       size_t get_total_memory() override;
   
       size_t get_from_driver_used_memory();
   
       size_t get_memory_limit();
   
       void allocate(std::size_t bytes);
   
       void deallocate(std::size_t bytes);
   
       void initialize(float host_mem_resouce_consumption_thresh);
   
       void finalize();
   
       bool isInitialized();
   
   private:
       blazing_host_memory_resource() = default;
       ~blazing_host_memory_resource() = default;
       blazing_host_memory_resource(const blazing_host_memory_resource&) = delete;
       blazing_host_memory_resource& operator=(const blazing_host_memory_resource&) = delete;
       std::mutex manager_mutex;
   
       bool is_initialized{false};
   
       std::unique_ptr<internal_blazing_host_memory_resource> initialized_resource{};
   };
   
   class blazing_disk_memory_resource : public  BlazingMemoryResource {
   public:
       static blazing_disk_memory_resource& getInstance() {
           // Myers' singleton. Thread safe and unique. Note: C++11 required.
           static blazing_disk_memory_resource instance;
           return instance;
       }
   
       // TODO: percy, cordova.Improve the design of get memory in real time 
       blazing_disk_memory_resource(float custom_threshold = 0.75);
   
       virtual ~blazing_disk_memory_resource() = default;
   
       virtual size_t get_from_driver_used_memory();
   
       size_t get_memory_limit();
   
       size_t get_memory_used();
   
       size_t get_total_memory();
   
   private:
       size_t total_memory_size;
       size_t memory_limit;
       std::atomic<size_t> used_memory_size;
   };
