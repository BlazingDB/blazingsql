
.. _program_listing_file_engine_src_communication_CommunicationInterface_messageReceiver.hpp:

Program Listing for File messageReceiver.hpp
============================================

|exhale_lsh| :ref:`Return to documentation for file <file_engine_src_communication_CommunicationInterface_messageReceiver.hpp>` (``engine/src/communication/CommunicationInterface/messageReceiver.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include "protocols.hpp"
   #include <vector>
   #include <map>
   #include <tuple>
   #include <memory>
   #include <rmm/device_buffer.hpp>
   #include <transport/ColumnTransport.h>
   #include "bmr/BufferProvider.h"
   #include "execution_graph/logic_controllers/CacheMachine.h"
   
   
   
   namespace comm {
   
   struct ucx_request {
       // https://github.com/rapidsai/ucx-py/blob/branch-0.15/ucp/_libs/ucx_api.pyx
       // Make sure to check on the latest branch !!!!!!!!!!!!!!!!!!!!!!!!!!!
       int completed; 
       int uid;       
   };
   
   
   struct blazing_ucp_tag {
       int  message_id;               
       uint16_t worker_origin_id; 
       uint16_t frame_id;         
   };
   
   
   class message_receiver {
   using ColumnTransport = blazingdb::transport::ColumnTransport;
   
   public:
   
     message_receiver(const std::map<std::string, comm::node>& nodes, const std::vector<char>& buffer, std::shared_ptr<ral::cache::CacheMachine> input_cache);
     virtual ~message_receiver(){}
   
     size_t buffer_size(u_int16_t index);
     void allocate_buffer(uint16_t index, cudaStream_t stream = 0);
     node get_sender_node();
     size_t num_buffers();
     void confirm_transmission();
     void * get_buffer(uint16_t index);
     bool is_finished();
     void finish(cudaStream_t stream = 0);
   private:
   
   
     std::vector<ColumnTransport> _column_transports;
     std::vector<ral::memory::blazing_chunked_column_info> _chunked_column_infos;
     std::shared_ptr<ral::cache::CacheMachine> _output_cache;
     ral::cache::MetadataDictionary _metadata;
     std::vector<size_t> _buffer_sizes;
     std::vector<std::unique_ptr<ral::memory::blazing_allocation_chunk> > _raw_buffers;
     std::map<std::string, comm::node> _nodes_info_map;
     std::atomic<int> _buffer_counter;
     std::mutex _finish_mutex;
     bool _finished_called = false;
     std::shared_ptr<ral::cache::CacheMachine> input_cache;
   };
   
   } // namespace comm
