\hypertarget{classral_1_1cache_1_1distributing__kernel}{}\section{ral\+:\+:cache\+:\+:distributing\+\_\+kernel Class Reference}
\label{classral_1_1cache_1_1distributing__kernel}\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}


The \hyperlink{classral_1_1cache_1_1distributing__kernel}{distributing\+\_\+kernel} interface allows kernels calling distributing primitives.  




{\ttfamily \#include $<$distributing\+\_\+kernel.\+h$>$}



Inheritance diagram for ral\+:\+:cache\+:\+:distributing\+\_\+kernel\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for ral\+:\+:cache\+:\+:distributing\+\_\+kernel\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=294pt]{classral_1_1cache_1_1distributing__kernel__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classral_1_1cache_1_1distributing__kernel_a7dd5d1d4ee0081e8570a893209d3c4bf}{distributing\+\_\+kernel} (std\+::size\+\_\+t \hyperlink{classral_1_1cache_1_1kernel_a2fd708656cb056a41ec635b8bdc4acfe}{kernel\+\_\+id}, std\+::string expr, std\+::shared\+\_\+ptr$<$ \hyperlink{classblazingdb_1_1manager_1_1Context}{Context} $>$ \hyperlink{classral_1_1cache_1_1kernel_af0347d14d678cfa7205c1387746a2e1b}{context}, kernel\+\_\+type \hyperlink{classral_1_1cache_1_1kernel_a923841bcb8d995048c58d51a6c39caf7}{kernel\+\_\+type\+\_\+id})
\item 
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_aacddbb29a0760b7d19cf52d3e5a4ff84}\label{classral_1_1cache_1_1distributing__kernel_aacddbb29a0760b7d19cf52d3e5a4ff84}} 
std\+::string {\bfseries kernel\+\_\+name} ()
\item 
void \hyperlink{classral_1_1cache_1_1distributing__kernel_a6466f289452c10450861276054b751da}{set\+\_\+number\+\_\+of\+\_\+message\+\_\+trackers} (std\+::size\+\_\+t num\+\_\+message\+\_\+trackers)
\begin{DoxyCompactList}\small\item\em Resizes the vector of the message trackers. Keeping more than one message tracker is useful for example for joins where we must keep track of separately for left and right partitions. \end{DoxyCompactList}\item 
void \hyperlink{classral_1_1cache_1_1distributing__kernel_aa2c88f7cefd4bb5eee4058c7059c277e}{send\+\_\+message} (std\+::unique\+\_\+ptr$<$ \hyperlink{classral_1_1frame_1_1BlazingTable}{ral\+::frame\+::\+Blazing\+Table} $>$ table, bool specific\+\_\+cache, std\+::string cache\+\_\+id, std\+::vector$<$ std\+::string $>$ target\+\_\+ids, std\+::string message\+\_\+id\+\_\+prefix=\char`\"{}\char`\"{}, bool always\+\_\+add=false, bool wait\+\_\+for=false, std\+::size\+\_\+t message\+\_\+tracker\+\_\+idx=0, \hyperlink{classral_1_1cache_1_1MetadataDictionary}{ral\+::cache\+::\+Metadata\+Dictionary} extra\+\_\+metadata=\{\})
\begin{DoxyCompactList}\small\item\em Sends a table with their corresponding metadata. \end{DoxyCompactList}\item 
void \hyperlink{classral_1_1cache_1_1distributing__kernel_ae2f86983ba3baca3a1f37ad7a6fc9326}{scatter} (std\+::vector$<$ \hyperlink{classral_1_1frame_1_1BlazingTableView}{ral\+::frame\+::\+Blazing\+Table\+View} $>$ partitions, \hyperlink{classral_1_1cache_1_1CacheMachine}{ral\+::cache\+::\+Cache\+Machine} $\ast$output, std\+::string message\+\_\+id\+\_\+prefix, std\+::string cache\+\_\+id, std\+::size\+\_\+t message\+\_\+tracker\+\_\+idx=0)
\begin{DoxyCompactList}\small\item\em Sends each partition to its corresponding nodes. It is assumed that the size of the vector is the same as the number of nodes. \end{DoxyCompactList}\item 
void \hyperlink{classral_1_1cache_1_1distributing__kernel_ac84717592ca882bcae7efd6a20ea2863}{scatter\+Parts} (std\+::vector$<$ ral\+::distribution\+::\+Node\+Column\+View $>$ partitions, std\+::string message\+\_\+id\+\_\+prefix, std\+::vector$<$ int32\+\_\+t $>$ part\+\_\+ids)
\begin{DoxyCompactList}\small\item\em Sends each partition to its corresponding nodes and corresponding part\+\_\+id More than one partition can belong to the same node. \end{DoxyCompactList}\item 
void \hyperlink{classral_1_1cache_1_1distributing__kernel_a943284f948c1f1486b04e6b02cdc3e19}{broadcast} (std\+::unique\+\_\+ptr$<$ \hyperlink{classral_1_1frame_1_1BlazingTable}{ral\+::frame\+::\+Blazing\+Table} $>$ table, \hyperlink{classral_1_1cache_1_1CacheMachine}{ral\+::cache\+::\+Cache\+Machine} $\ast$output, std\+::string message\+\_\+id\+\_\+prefix, std\+::string cache\+\_\+id, std\+::size\+\_\+t message\+\_\+tracker\+\_\+idx=0, bool always\+\_\+add=false)
\begin{DoxyCompactList}\small\item\em Sends same table to all other nodes. \end{DoxyCompactList}\item 
void \hyperlink{classral_1_1cache_1_1distributing__kernel_a532f4eb42963c4e76199f9250c483a09}{send\+\_\+total\+\_\+partition\+\_\+counts} (std\+::string message\+\_\+id\+\_\+prefix, std\+::string cache\+\_\+id, std\+::size\+\_\+t message\+\_\+tracker\+\_\+idx=0)
\begin{DoxyCompactList}\small\item\em Sends the partition counter to all other nodes. These sent counters represent the number of messages that each node should wait on their end. \end{DoxyCompactList}\item 
int \hyperlink{classral_1_1cache_1_1distributing__kernel_ae5f1a597fc3716c344b54b6d0d6af311}{get\+\_\+total\+\_\+partition\+\_\+counts} (std\+::size\+\_\+t message\+\_\+tracker\+\_\+idx=0)
\begin{DoxyCompactList}\small\item\em Get the total partition counters associated to a message tracker. The total counter returned by this function usually is the input for function \hyperlink{classral_1_1cache_1_1WaitingQueue_abd7d9824f1b89ead2c937e1c6d64ba4f}{Waiting\+Queue\+::wait\+\_\+for\+\_\+count()} that allows waiting for the arrival of a certain number of messages. \end{DoxyCompactList}\item 
void \hyperlink{classral_1_1cache_1_1distributing__kernel_a304a30bf1847aab1dd6a9779bbc80929}{increment\+\_\+node\+\_\+count} (std\+::string node\+\_\+id, std\+::size\+\_\+t message\+\_\+tracker\+\_\+idx=0)
\begin{DoxyCompactList}\small\item\em Increments by one the corresponding node counter associated to the node identifier and the message tracker identifier. Every time data is added to a cache, the node counter must be incremented by one. \end{DoxyCompactList}\item 
virtual \hyperlink{classral_1_1cache_1_1distributing__kernel_a19afe37abf9e6a2f29f2a83d45ecf093}{$\sim$distributing\+\_\+kernel} ()=default
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
The \hyperlink{classral_1_1cache_1_1distributing__kernel}{distributing\+\_\+kernel} interface allows kernels calling distributing primitives. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_a7dd5d1d4ee0081e8570a893209d3c4bf}\label{classral_1_1cache_1_1distributing__kernel_a7dd5d1d4ee0081e8570a893209d3c4bf}} 
\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}!distributing\+\_\+kernel@{distributing\+\_\+kernel}}
\index{distributing\+\_\+kernel@{distributing\+\_\+kernel}!ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}
\subsubsection{\texorpdfstring{distributing\+\_\+kernel()}{distributing\_kernel()}}
{\footnotesize\ttfamily ral\+::cache\+::distributing\+\_\+kernel\+::distributing\+\_\+kernel (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{kernel\+\_\+id,  }\item[{std\+::string}]{expr,  }\item[{std\+::shared\+\_\+ptr$<$ \hyperlink{classblazingdb_1_1manager_1_1Context}{Context} $>$}]{context,  }\item[{kernel\+\_\+type}]{kernel\+\_\+type\+\_\+id }\end{DoxyParamCaption})}

Constructor for the \hyperlink{classral_1_1cache_1_1distributing__kernel}{distributing\+\_\+kernel} 
\begin{DoxyParams}{Parameters}
{\em kernel\+\_\+id} & Current kernel identifier. \\
\hline
{\em expr} & Original logical expression that the kernel will execute. \\
\hline
{\em context} & Shared context associated to the running query. \\
\hline
{\em kernel\+\_\+type\+\_\+id} & Identifier representing the kernel type. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_a19afe37abf9e6a2f29f2a83d45ecf093}\label{classral_1_1cache_1_1distributing__kernel_a19afe37abf9e6a2f29f2a83d45ecf093}} 
\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}!````~distributing\+\_\+kernel@{$\sim$distributing\+\_\+kernel}}
\index{````~distributing\+\_\+kernel@{$\sim$distributing\+\_\+kernel}!ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}
\subsubsection{\texorpdfstring{$\sim$distributing\+\_\+kernel()}{~distributing\_kernel()}}
{\footnotesize\ttfamily virtual ral\+::cache\+::distributing\+\_\+kernel\+::$\sim$distributing\+\_\+kernel (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}

Destructor 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_a943284f948c1f1486b04e6b02cdc3e19}\label{classral_1_1cache_1_1distributing__kernel_a943284f948c1f1486b04e6b02cdc3e19}} 
\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}!broadcast@{broadcast}}
\index{broadcast@{broadcast}!ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}
\subsubsection{\texorpdfstring{broadcast()}{broadcast()}}
{\footnotesize\ttfamily void ral\+::cache\+::distributing\+\_\+kernel\+::broadcast (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \hyperlink{classral_1_1frame_1_1BlazingTable}{ral\+::frame\+::\+Blazing\+Table} $>$}]{table,  }\item[{\hyperlink{classral_1_1cache_1_1CacheMachine}{ral\+::cache\+::\+Cache\+Machine} $\ast$}]{output,  }\item[{std\+::string}]{message\+\_\+id\+\_\+prefix,  }\item[{std\+::string}]{cache\+\_\+id,  }\item[{std\+::size\+\_\+t}]{message\+\_\+tracker\+\_\+idx = {\ttfamily 0},  }\item[{bool}]{always\+\_\+add = {\ttfamily false} }\end{DoxyParamCaption})}



Sends same table to all other nodes. 


\begin{DoxyParams}{Parameters}
{\em table} & The table to be broadcast \\
\hline
{\em output} & The output cache. \\
\hline
{\em message\+\_\+id\+\_\+prefix} & The prefix of the identifier of this message. \\
\hline
{\em cache\+\_\+id} & Indicates what cache a message should be routed to. \\
\hline
{\em message\+\_\+tracker\+\_\+idx} & The message tracker index. \\
\hline
{\em always\+\_\+add} & Forces to always send the message \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_a943284f948c1f1486b04e6b02cdc3e19_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_a943284f948c1f1486b04e6b02cdc3e19_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_ae5f1a597fc3716c344b54b6d0d6af311}\label{classral_1_1cache_1_1distributing__kernel_ae5f1a597fc3716c344b54b6d0d6af311}} 
\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}!get\+\_\+total\+\_\+partition\+\_\+counts@{get\+\_\+total\+\_\+partition\+\_\+counts}}
\index{get\+\_\+total\+\_\+partition\+\_\+counts@{get\+\_\+total\+\_\+partition\+\_\+counts}!ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}
\subsubsection{\texorpdfstring{get\+\_\+total\+\_\+partition\+\_\+counts()}{get\_total\_partition\_counts()}}
{\footnotesize\ttfamily int ral\+::cache\+::distributing\+\_\+kernel\+::get\+\_\+total\+\_\+partition\+\_\+counts (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{message\+\_\+tracker\+\_\+idx = {\ttfamily 0} }\end{DoxyParamCaption})}



Get the total partition counters associated to a message tracker. The total counter returned by this function usually is the input for function \hyperlink{classral_1_1cache_1_1WaitingQueue_abd7d9824f1b89ead2c937e1c6d64ba4f}{Waiting\+Queue\+::wait\+\_\+for\+\_\+count()} that allows waiting for the arrival of a certain number of messages. 


\begin{DoxyParams}{Parameters}
{\em message\+\_\+tracker\+\_\+idx} & The message tracker index. \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_ae5f1a597fc3716c344b54b6d0d6af311_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_a304a30bf1847aab1dd6a9779bbc80929}\label{classral_1_1cache_1_1distributing__kernel_a304a30bf1847aab1dd6a9779bbc80929}} 
\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}!increment\+\_\+node\+\_\+count@{increment\+\_\+node\+\_\+count}}
\index{increment\+\_\+node\+\_\+count@{increment\+\_\+node\+\_\+count}!ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}
\subsubsection{\texorpdfstring{increment\+\_\+node\+\_\+count()}{increment\_node\_count()}}
{\footnotesize\ttfamily void ral\+::cache\+::distributing\+\_\+kernel\+::increment\+\_\+node\+\_\+count (\begin{DoxyParamCaption}\item[{std\+::string}]{node\+\_\+id,  }\item[{std\+::size\+\_\+t}]{message\+\_\+tracker\+\_\+idx = {\ttfamily 0} }\end{DoxyParamCaption})}



Increments by one the corresponding node counter associated to the node identifier and the message tracker identifier. Every time data is added to a cache, the node counter must be incremented by one. 


\begin{DoxyParams}{Parameters}
{\em node\+\_\+id} & The node identifier. \\
\hline
{\em message\+\_\+tracker\+\_\+idx} & The message tracker index. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_ae2f86983ba3baca3a1f37ad7a6fc9326}\label{classral_1_1cache_1_1distributing__kernel_ae2f86983ba3baca3a1f37ad7a6fc9326}} 
\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}!scatter@{scatter}}
\index{scatter@{scatter}!ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}
\subsubsection{\texorpdfstring{scatter()}{scatter()}}
{\footnotesize\ttfamily void ral\+::cache\+::distributing\+\_\+kernel\+::scatter (\begin{DoxyParamCaption}\item[{std\+::vector$<$ \hyperlink{classral_1_1frame_1_1BlazingTableView}{ral\+::frame\+::\+Blazing\+Table\+View} $>$}]{partitions,  }\item[{\hyperlink{classral_1_1cache_1_1CacheMachine}{ral\+::cache\+::\+Cache\+Machine} $\ast$}]{output,  }\item[{std\+::string}]{message\+\_\+id\+\_\+prefix,  }\item[{std\+::string}]{cache\+\_\+id,  }\item[{std\+::size\+\_\+t}]{message\+\_\+tracker\+\_\+idx = {\ttfamily 0} }\end{DoxyParamCaption})}



Sends each partition to its corresponding nodes. It is assumed that the size of the vector is the same as the number of nodes. 


\begin{DoxyParams}{Parameters}
{\em partitions} & The table partitions to be sent. \\
\hline
{\em output} & The output cache. \\
\hline
{\em message\+\_\+id\+\_\+prefix} & The prefix of the identifier of this message. \\
\hline
{\em cache\+\_\+id} & Indicates what cache a message should be routed to. \\
\hline
{\em message\+\_\+tracker\+\_\+idx} & The message tracker index. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_ae2f86983ba3baca3a1f37ad7a6fc9326_cgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_ac84717592ca882bcae7efd6a20ea2863}\label{classral_1_1cache_1_1distributing__kernel_ac84717592ca882bcae7efd6a20ea2863}} 
\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}!scatter\+Parts@{scatter\+Parts}}
\index{scatter\+Parts@{scatter\+Parts}!ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}
\subsubsection{\texorpdfstring{scatter\+Parts()}{scatterParts()}}
{\footnotesize\ttfamily void ral\+::cache\+::distributing\+\_\+kernel\+::scatter\+Parts (\begin{DoxyParamCaption}\item[{std\+::vector$<$ ral\+::distribution\+::\+Node\+Column\+View $>$}]{partitions,  }\item[{std\+::string}]{message\+\_\+id\+\_\+prefix,  }\item[{std\+::vector$<$ int32\+\_\+t $>$}]{part\+\_\+ids }\end{DoxyParamCaption})}



Sends each partition to its corresponding nodes and corresponding part\+\_\+id More than one partition can belong to the same node. 


\begin{DoxyParams}{Parameters}
{\em partitions} & The table partitions to be sent represented as node column views. \\
\hline
{\em message\+\_\+id\+\_\+prefix} & The prefix of the identifier of this message. \\
\hline
{\em part\+\_\+ids} & A vector the same size as partitions, telling which part\+\_\+id each partition corresponds to. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_ac84717592ca882bcae7efd6a20ea2863_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_ac84717592ca882bcae7efd6a20ea2863_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_aa2c88f7cefd4bb5eee4058c7059c277e}\label{classral_1_1cache_1_1distributing__kernel_aa2c88f7cefd4bb5eee4058c7059c277e}} 
\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}!send\+\_\+message@{send\+\_\+message}}
\index{send\+\_\+message@{send\+\_\+message}!ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}
\subsubsection{\texorpdfstring{send\+\_\+message()}{send\_message()}}
{\footnotesize\ttfamily void ral\+::cache\+::distributing\+\_\+kernel\+::send\+\_\+message (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \hyperlink{classral_1_1frame_1_1BlazingTable}{ral\+::frame\+::\+Blazing\+Table} $>$}]{table,  }\item[{bool}]{specific\+\_\+cache,  }\item[{std\+::string}]{cache\+\_\+id,  }\item[{std\+::vector$<$ std\+::string $>$}]{target\+\_\+ids,  }\item[{std\+::string}]{message\+\_\+id\+\_\+prefix = {\ttfamily \char`\"{}\char`\"{}},  }\item[{bool}]{always\+\_\+add = {\ttfamily false},  }\item[{bool}]{wait\+\_\+for = {\ttfamily false},  }\item[{std\+::size\+\_\+t}]{message\+\_\+tracker\+\_\+idx = {\ttfamily 0},  }\item[{\hyperlink{classral_1_1cache_1_1MetadataDictionary}{ral\+::cache\+::\+Metadata\+Dictionary}}]{extra\+\_\+metadata = {\ttfamily \{\}} }\end{DoxyParamCaption})}



Sends a table with their corresponding metadata. 


\begin{DoxyParams}{Parameters}
{\em table} & The table to be sent. If table is a nullptr, an empty table is sent anyways. \\
\hline
{\em specific\+\_\+cache} & Indicates if a message should be routed to a specific cache or to the global input cache. \\
\hline
{\em cache\+\_\+id} & Indicates what cache a message should be routed to. \\
\hline
{\em target\+\_\+id} & Vector of workers that will be receiving this message. \\
\hline
{\em message\+\_\+id\+\_\+prefix} & The prefix of the identifier of this message. \\
\hline
{\em always\+\_\+add} & Forces to always add the table to the output cache. \\
\hline
{\em wait\+\_\+for} & Indicates if this message must be registered to wait for back. \\
\hline
{\em message\+\_\+tracker\+\_\+idx} & The message tracker index. \\
\hline
{\em extra\+\_\+metadata} & The cache identifier. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_aa2c88f7cefd4bb5eee4058c7059c277e_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_aa2c88f7cefd4bb5eee4058c7059c277e_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_a532f4eb42963c4e76199f9250c483a09}\label{classral_1_1cache_1_1distributing__kernel_a532f4eb42963c4e76199f9250c483a09}} 
\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}!send\+\_\+total\+\_\+partition\+\_\+counts@{send\+\_\+total\+\_\+partition\+\_\+counts}}
\index{send\+\_\+total\+\_\+partition\+\_\+counts@{send\+\_\+total\+\_\+partition\+\_\+counts}!ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}
\subsubsection{\texorpdfstring{send\+\_\+total\+\_\+partition\+\_\+counts()}{send\_total\_partition\_counts()}}
{\footnotesize\ttfamily void ral\+::cache\+::distributing\+\_\+kernel\+::send\+\_\+total\+\_\+partition\+\_\+counts (\begin{DoxyParamCaption}\item[{std\+::string}]{message\+\_\+id\+\_\+prefix,  }\item[{std\+::string}]{cache\+\_\+id,  }\item[{std\+::size\+\_\+t}]{message\+\_\+tracker\+\_\+idx = {\ttfamily 0} }\end{DoxyParamCaption})}



Sends the partition counter to all other nodes. These sent counters represent the number of messages that each node should wait on their end. 


\begin{DoxyParams}{Parameters}
{\em message\+\_\+id\+\_\+prefix} & The prefix of the identifier of this message. \\
\hline
{\em cache\+\_\+id} & Indicates what cache a message should be routed to. \\
\hline
{\em message\+\_\+tracker\+\_\+idx} & The message tracker index. \\
\hline
\end{DoxyParams}
Here is the call graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_a532f4eb42963c4e76199f9250c483a09_cgraph}
\end{center}
\end{figure}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_a532f4eb42963c4e76199f9250c483a09_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classral_1_1cache_1_1distributing__kernel_a6466f289452c10450861276054b751da}\label{classral_1_1cache_1_1distributing__kernel_a6466f289452c10450861276054b751da}} 
\index{ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}!set\+\_\+number\+\_\+of\+\_\+message\+\_\+trackers@{set\+\_\+number\+\_\+of\+\_\+message\+\_\+trackers}}
\index{set\+\_\+number\+\_\+of\+\_\+message\+\_\+trackers@{set\+\_\+number\+\_\+of\+\_\+message\+\_\+trackers}!ral\+::cache\+::distributing\+\_\+kernel@{ral\+::cache\+::distributing\+\_\+kernel}}
\subsubsection{\texorpdfstring{set\+\_\+number\+\_\+of\+\_\+message\+\_\+trackers()}{set\_number\_of\_message\_trackers()}}
{\footnotesize\ttfamily void ral\+::cache\+::distributing\+\_\+kernel\+::set\+\_\+number\+\_\+of\+\_\+message\+\_\+trackers (\begin{DoxyParamCaption}\item[{std\+::size\+\_\+t}]{num\+\_\+message\+\_\+trackers }\end{DoxyParamCaption})}



Resizes the vector of the message trackers. Keeping more than one message tracker is useful for example for joins where we must keep track of separately for left and right partitions. 


\begin{DoxyParams}{Parameters}
{\em num\+\_\+message\+\_\+trackers} & The new number of the message trackers. \\
\hline
\end{DoxyParams}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1cache_1_1distributing__kernel_a6466f289452c10450861276054b751da_icgraph}
\end{center}
\end{figure}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/tom/\+Documents/programming/romulo\+\_\+blazingsql/blazingsql/engine/src/execution\+\_\+graph/logic\+\_\+controllers/taskflow/distributing\+\_\+kernel.\+h\item 
/home/tom/\+Documents/programming/romulo\+\_\+blazingsql/blazingsql/engine/src/execution\+\_\+graph/logic\+\_\+controllers/taskflow/distributing\+\_\+kernel.\+cpp\end{DoxyCompactItemize}
