\hypertarget{classral_1_1batch_1_1BatchSequenceBypass}{}\section{ral\+:\+:batch\+:\+:Batch\+Sequence\+Bypass Class Reference}
\label{classral_1_1batch_1_1BatchSequenceBypass}\index{ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}}


This data sequencer works as a bypass to take data from one input to an output without decacheing.  




{\ttfamily \#include $<$Batch\+Processing.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classral_1_1batch_1_1BatchSequenceBypass_aece145bb27dd1aa61252a831b8d0b536}{Batch\+Sequence\+Bypass} (std\+::shared\+\_\+ptr$<$ \hyperlink{classral_1_1cache_1_1CacheMachine}{ral\+::cache\+::\+Cache\+Machine} $>$ cache=nullptr, const \hyperlink{classral_1_1cache_1_1kernel}{ral\+::cache\+::kernel} $\ast$\hyperlink{classral_1_1cache_1_1kernel}{kernel}=nullptr)
\item 
void \hyperlink{classral_1_1batch_1_1BatchSequenceBypass_aaf3b8397046f0ad622a49c751861d983}{set\+\_\+source} (std\+::shared\+\_\+ptr$<$ \hyperlink{classral_1_1cache_1_1CacheMachine}{ral\+::cache\+::\+Cache\+Machine} $>$ cache)
\item 
std\+::unique\+\_\+ptr$<$ \hyperlink{classral_1_1cache_1_1CacheData}{ral\+::cache\+::\+Cache\+Data} $>$ \hyperlink{classral_1_1batch_1_1BatchSequenceBypass_a5d55f785961b21c82578223ab5a0a217}{next} ()
\item 
bool \hyperlink{classral_1_1batch_1_1BatchSequenceBypass_a623422aa9164a34bce024e92f4f26679}{wait\+\_\+for\+\_\+next} ()
\item 
bool \hyperlink{classral_1_1batch_1_1BatchSequenceBypass_a221ad94710394f83ebbeeabcc1851b22}{has\+\_\+next\+\_\+now} ()
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This data sequencer works as a bypass to take data from one input to an output without decacheing. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classral_1_1batch_1_1BatchSequenceBypass_aece145bb27dd1aa61252a831b8d0b536}\label{classral_1_1batch_1_1BatchSequenceBypass_aece145bb27dd1aa61252a831b8d0b536}} 
\index{ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}!Batch\+Sequence\+Bypass@{Batch\+Sequence\+Bypass}}
\index{Batch\+Sequence\+Bypass@{Batch\+Sequence\+Bypass}!ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}}
\subsubsection{\texorpdfstring{Batch\+Sequence\+Bypass()}{BatchSequenceBypass()}}
{\footnotesize\ttfamily ral\+::batch\+::\+Batch\+Sequence\+Bypass\+::\+Batch\+Sequence\+Bypass (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \hyperlink{classral_1_1cache_1_1CacheMachine}{ral\+::cache\+::\+Cache\+Machine} $>$}]{cache = {\ttfamily nullptr},  }\item[{const \hyperlink{classral_1_1cache_1_1kernel}{ral\+::cache\+::kernel} $\ast$}]{kernel = {\ttfamily nullptr} }\end{DoxyParamCaption})}

Constructor for the \hyperlink{classral_1_1batch_1_1BatchSequenceBypass}{Batch\+Sequence\+Bypass} 
\begin{DoxyParams}{Parameters}
{\em cache} & The input cache from where the data will be pulled. \\
\hline
{\em kernel} & The kernel that will actually receive the pulled data. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{classral_1_1batch_1_1BatchSequenceBypass_a221ad94710394f83ebbeeabcc1851b22}\label{classral_1_1batch_1_1BatchSequenceBypass_a221ad94710394f83ebbeeabcc1851b22}} 
\index{ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}!has\+\_\+next\+\_\+now@{has\+\_\+next\+\_\+now}}
\index{has\+\_\+next\+\_\+now@{has\+\_\+next\+\_\+now}!ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}}
\subsubsection{\texorpdfstring{has\+\_\+next\+\_\+now()}{has\_next\_now()}}
{\footnotesize\ttfamily bool ral\+::batch\+::\+Batch\+Sequence\+Bypass\+::has\+\_\+next\+\_\+now (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Indicates if the message queue is not empty at this point on time. \begin{DoxyReturn}{Returns}
true There is at least one message in the queue. 

false Message queue is empty. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1batch_1_1BatchSequenceBypass_a5d55f785961b21c82578223ab5a0a217}\label{classral_1_1batch_1_1BatchSequenceBypass_a5d55f785961b21c82578223ab5a0a217}} 
\index{ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}!next@{next}}
\index{next@{next}!ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}}
\subsubsection{\texorpdfstring{next()}{next()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \hyperlink{classral_1_1cache_1_1CacheData}{ral\+::cache\+::\+Cache\+Data} $>$ ral\+::batch\+::\+Batch\+Sequence\+Bypass\+::next (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the next message as a Cache\+Data object. \begin{DoxyReturn}{Returns}
Cache\+Data containing the next message without decacheing. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1batch_1_1BatchSequenceBypass_a5d55f785961b21c82578223ab5a0a217_icgraph}
\end{center}
\end{figure}
\mbox{\Hypertarget{classral_1_1batch_1_1BatchSequenceBypass_aaf3b8397046f0ad622a49c751861d983}\label{classral_1_1batch_1_1BatchSequenceBypass_aaf3b8397046f0ad622a49c751861d983}} 
\index{ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}!set\+\_\+source@{set\+\_\+source}}
\index{set\+\_\+source@{set\+\_\+source}!ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}}
\subsubsection{\texorpdfstring{set\+\_\+source()}{set\_source()}}
{\footnotesize\ttfamily void ral\+::batch\+::\+Batch\+Sequence\+Bypass\+::set\+\_\+source (\begin{DoxyParamCaption}\item[{std\+::shared\+\_\+ptr$<$ \hyperlink{classral_1_1cache_1_1CacheMachine}{ral\+::cache\+::\+Cache\+Machine} $>$}]{cache }\end{DoxyParamCaption})}

Updates the input cache machine. 
\begin{DoxyParams}{Parameters}
{\em cache} & The pointer to the new input cache. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classral_1_1batch_1_1BatchSequenceBypass_a623422aa9164a34bce024e92f4f26679}\label{classral_1_1batch_1_1BatchSequenceBypass_a623422aa9164a34bce024e92f4f26679}} 
\index{ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}!wait\+\_\+for\+\_\+next@{wait\+\_\+for\+\_\+next}}
\index{wait\+\_\+for\+\_\+next@{wait\+\_\+for\+\_\+next}!ral\+::batch\+::\+Batch\+Sequence\+Bypass@{ral\+::batch\+::\+Batch\+Sequence\+Bypass}}
\subsubsection{\texorpdfstring{wait\+\_\+for\+\_\+next()}{wait\_for\_next()}}
{\footnotesize\ttfamily bool ral\+::batch\+::\+Batch\+Sequence\+Bypass\+::wait\+\_\+for\+\_\+next (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Blocks executing thread until a new message is ready or when the message queue is empty. \begin{DoxyReturn}{Returns}
true A new message is ready. 

false There are no more messages on the cache. 
\end{DoxyReturn}
Here is the caller graph for this function\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{classral_1_1batch_1_1BatchSequenceBypass_a623422aa9164a34bce024e92f4f26679_icgraph}
\end{center}
\end{figure}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
/home/tom/\+Documents/programming/romulo\+\_\+blazingsql/blazingsql/engine/src/execution\+\_\+graph/logic\+\_\+controllers/Batch\+Processing.\+h\item 
/home/tom/\+Documents/programming/romulo\+\_\+blazingsql/blazingsql/engine/src/execution\+\_\+graph/logic\+\_\+controllers/Batch\+Processing.\+cpp\end{DoxyCompactItemize}
