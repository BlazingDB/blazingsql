\hypertarget{classral_1_1cache_1_1WaitingQueue}{}\section{ral\+:\+:cache\+:\+:Waiting\+Queue$<$ message\+\_\+ptr $>$ Class Template Reference}
\label{classral_1_1cache_1_1WaitingQueue}\index{ral\+::cache\+::\+Waiting\+Queue$<$ message\+\_\+ptr $>$@{ral\+::cache\+::\+Waiting\+Queue$<$ message\+\_\+ptr $>$}}


{\ttfamily \#include $<$Waiting\+Queue.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classral_1_1cache_1_1WaitingQueue_ac69033b0cfeead472b2b0beeed6de93c}{Waiting\+Queue} (std\+::string queue\+\_\+name, int timeout=60000, bool log\+\_\+timeout=true)
\item 
\hyperlink{classral_1_1cache_1_1WaitingQueue_a09240aad671d08e2df7fe90b0a3a268b}{$\sim$\+Waiting\+Queue} ()=default
\item 
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a2c072bc505d3b6e48eef52b3adb98cfd}\label{classral_1_1cache_1_1WaitingQueue_a2c072bc505d3b6e48eef52b3adb98cfd}} 
{\bfseries Waiting\+Queue} (\hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} \&\&)=delete
\item 
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_afc562f0200a6f5e1a9791473ea6398ba}\label{classral_1_1cache_1_1WaitingQueue_afc562f0200a6f5e1a9791473ea6398ba}} 
{\bfseries Waiting\+Queue} (const \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} \&)=delete
\item 
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a46e9b5f6c88e3ad5a6b54ce2ee7ffbfa}\label{classral_1_1cache_1_1WaitingQueue_a46e9b5f6c88e3ad5a6b54ce2ee7ffbfa}} 
\hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} \& {\bfseries operator=} (\hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} \&\&)=delete
\item 
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_afd572305420b7188aab015b2949fe082}\label{classral_1_1cache_1_1WaitingQueue_afd572305420b7188aab015b2949fe082}} 
\hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} \& {\bfseries operator=} (const \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} \&)=delete
\item 
void \hyperlink{classral_1_1cache_1_1WaitingQueue_a8049784eaf2ca3f33b3ed9accd2222d2}{put} (message\+\_\+ptr item)
\item 
int \hyperlink{classral_1_1cache_1_1WaitingQueue_af3afa691f12cfe644d86e8c1f99a31ec}{processed\+\_\+parts} ()
\item 
void \hyperlink{classral_1_1cache_1_1WaitingQueue_af489dc4d0c5cb810109beb3e9ff97062}{finish} ()
\item 
bool \hyperlink{classral_1_1cache_1_1WaitingQueue_a33631ea402ae98a42b144bc3f1453341}{is\+\_\+finished} ()
\item 
void \hyperlink{classral_1_1cache_1_1WaitingQueue_abd7d9824f1b89ead2c937e1c6d64ba4f}{wait\+\_\+for\+\_\+count} (int count)
\item 
message\+\_\+ptr \hyperlink{classral_1_1cache_1_1WaitingQueue_afbc5898a999bb8b5257c5de1b656db1c}{pop\+\_\+or\+\_\+wait} ()
\item 
message\+\_\+ptr \hyperlink{classral_1_1cache_1_1WaitingQueue_a259a82267567c6b5da96bd1bac53f6db}{pop\+\_\+back} ()
\item 
bool \hyperlink{classral_1_1cache_1_1WaitingQueue_a2849a6f841c2958aba489237a24ec0df}{wait\+\_\+for\+\_\+next} ()
\item 
bool \hyperlink{classral_1_1cache_1_1WaitingQueue_ac365aaf9f942c2d5ac22087cbfaf5968}{has\+\_\+next\+\_\+now} ()
\item 
void \hyperlink{classral_1_1cache_1_1WaitingQueue_a008f9d8254330dff1e653bd41fe43d9a}{wait\+\_\+until\+\_\+finished} ()
\item 
void \hyperlink{classral_1_1cache_1_1WaitingQueue_a84d4f711f11a11970b381b5b5c5d5662}{wait\+\_\+until\+\_\+num\+\_\+bytes} (size\+\_\+t num\+\_\+bytes)
\item 
size\+\_\+t \hyperlink{classral_1_1cache_1_1WaitingQueue_acbb3be52777e0a087a969b220377177a}{get\+\_\+next\+\_\+size\+\_\+in\+\_\+bytes} ()
\item 
message\+\_\+ptr \hyperlink{classral_1_1cache_1_1WaitingQueue_a8225fd0f55e72bf630f261def644d527}{get\+\_\+or\+\_\+wait} (std\+::string message\+\_\+id)
\item 
message\+\_\+ptr \hyperlink{classral_1_1cache_1_1WaitingQueue_a0ba9790cb2d41d01f7721b9972e4ff44}{pop\+\_\+unsafe} ()
\item 
std\+::vector$<$ message\+\_\+ptr $>$ \hyperlink{classral_1_1cache_1_1WaitingQueue_a51a2c83824c2f9eefe8b938a19793645}{get\+\_\+all} ()
\item 
std\+::vector$<$ std\+::string $>$ \hyperlink{classral_1_1cache_1_1WaitingQueue_ace97207416c27ecbe0d356c096edb499}{get\+\_\+all\+\_\+message\+\_\+ids} ()
\item 
std\+::vector$<$ message\+\_\+ptr $>$ \hyperlink{classral_1_1cache_1_1WaitingQueue_a0f0d4eb7e1d573849af13ede6621f2ac}{get\+\_\+all\+\_\+or\+\_\+wait} ()
\item 
std\+::unique\+\_\+lock$<$ std\+::mutex $>$ \hyperlink{classral_1_1cache_1_1WaitingQueue_ad5ef46c8b24d7de3f2a00c4e6f927e0a}{lock} ()
\item 
std\+::vector$<$ message\+\_\+ptr $>$ \hyperlink{classral_1_1cache_1_1WaitingQueue_a6b0d10905ba8ab60f8d171d494e9ed7a}{get\+\_\+all\+\_\+unsafe} ()
\item 
void \hyperlink{classral_1_1cache_1_1WaitingQueue_a1ac476114c34c127aee7c43907088bea}{put\+\_\+all\+\_\+unsafe} (std\+::vector$<$ message\+\_\+ptr $>$ messages)
\item 
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a523bc3b04a12b26ac57b8c77f0634fb5}\label{classral_1_1cache_1_1WaitingQueue_a523bc3b04a12b26ac57b8c77f0634fb5}} 
void {\bfseries put\+\_\+all} (std\+::vector$<$ message\+\_\+ptr $>$ messages)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename message\+\_\+ptr$>$\newline
class ral\+::cache\+::\+Waiting\+Queue$<$ message\+\_\+ptr $>$}

A Queue that has built in methods for waiting operations. The purpose of \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} is to provide apis that get things out of the queue when they exist and wait for things when they don\textquotesingle{}t without consuming many compute resources.\+This is accomplished through the use of a condition\+\_\+variable and mutex locks. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_ac69033b0cfeead472b2b0beeed6de93c}\label{classral_1_1cache_1_1WaitingQueue_ac69033b0cfeead472b2b0beeed6de93c}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!Waiting\+Queue@{Waiting\+Queue}}
\index{Waiting\+Queue@{Waiting\+Queue}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{Waiting\+Queue()}{WaitingQueue()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
\hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::\hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} (\begin{DoxyParamCaption}\item[{std\+::string}]{queue\+\_\+name,  }\item[{int}]{timeout = {\ttfamily 60000},  }\item[{bool}]{log\+\_\+timeout = {\ttfamily true} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Constructor \mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a09240aad671d08e2df7fe90b0a3a268b}\label{classral_1_1cache_1_1WaitingQueue_a09240aad671d08e2df7fe90b0a3a268b}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!````~Waiting\+Queue@{$\sim$\+Waiting\+Queue}}
\index{````~Waiting\+Queue@{$\sim$\+Waiting\+Queue}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{$\sim$\+Waiting\+Queue()}{~WaitingQueue()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
\hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::$\sim$\hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}

Destructor 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_af489dc4d0c5cb810109beb3e9ff97062}\label{classral_1_1cache_1_1WaitingQueue_af489dc4d0c5cb810109beb3e9ff97062}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!finish@{finish}}
\index{finish@{finish}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{finish()}{finish()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
void \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::finish (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Finish lets us know that know more messages will come in. This exists so that if anyone is trying to pull from a queue that is already completed that operation will return nullptr so it will not block indefinitely. \mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a51a2c83824c2f9eefe8b938a19793645}\label{classral_1_1cache_1_1WaitingQueue_a51a2c83824c2f9eefe8b938a19793645}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!get\+\_\+all@{get\+\_\+all}}
\index{get\+\_\+all@{get\+\_\+all}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{get\+\_\+all()}{get\_all()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
std\+::vector$<$message\+\_\+ptr$>$ \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::get\+\_\+all (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

gets all the messages \mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_ace97207416c27ecbe0d356c096edb499}\label{classral_1_1cache_1_1WaitingQueue_ace97207416c27ecbe0d356c096edb499}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!get\+\_\+all\+\_\+message\+\_\+ids@{get\+\_\+all\+\_\+message\+\_\+ids}}
\index{get\+\_\+all\+\_\+message\+\_\+ids@{get\+\_\+all\+\_\+message\+\_\+ids}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{get\+\_\+all\+\_\+message\+\_\+ids()}{get\_all\_message\_ids()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
std\+::vector$<$std\+::string$>$ \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::get\+\_\+all\+\_\+message\+\_\+ids (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

gets all the message ids \mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a0f0d4eb7e1d573849af13ede6621f2ac}\label{classral_1_1cache_1_1WaitingQueue_a0f0d4eb7e1d573849af13ede6621f2ac}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!get\+\_\+all\+\_\+or\+\_\+wait@{get\+\_\+all\+\_\+or\+\_\+wait}}
\index{get\+\_\+all\+\_\+or\+\_\+wait@{get\+\_\+all\+\_\+or\+\_\+wait}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{get\+\_\+all\+\_\+or\+\_\+wait()}{get\_all\_or\_wait()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
std\+::vector$<$message\+\_\+ptr$>$ \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::get\+\_\+all\+\_\+or\+\_\+wait (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Waits until all messages are ready then returns all of them. You should never call this function more than once on a \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} else race conditions can occur. \begin{DoxyReturn}{Returns}
A vector of all the messages that were inserted into the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a6b0d10905ba8ab60f8d171d494e9ed7a}\label{classral_1_1cache_1_1WaitingQueue_a6b0d10905ba8ab60f8d171d494e9ed7a}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!get\+\_\+all\+\_\+unsafe@{get\+\_\+all\+\_\+unsafe}}
\index{get\+\_\+all\+\_\+unsafe@{get\+\_\+all\+\_\+unsafe}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{get\+\_\+all\+\_\+unsafe()}{get\_all\_unsafe()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
std\+::vector$<$message\+\_\+ptr$>$ \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::get\+\_\+all\+\_\+unsafe (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Get all messagse in the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} without locking. \begin{DoxyReturn}{Returns}
A vector with all the messages in the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_acbb3be52777e0a087a969b220377177a}\label{classral_1_1cache_1_1WaitingQueue_acbb3be52777e0a087a969b220377177a}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!get\+\_\+next\+\_\+size\+\_\+in\+\_\+bytes@{get\+\_\+next\+\_\+size\+\_\+in\+\_\+bytes}}
\index{get\+\_\+next\+\_\+size\+\_\+in\+\_\+bytes@{get\+\_\+next\+\_\+size\+\_\+in\+\_\+bytes}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{get\+\_\+next\+\_\+size\+\_\+in\+\_\+bytes()}{get\_next\_size\_in\_bytes()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
size\+\_\+t \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::get\+\_\+next\+\_\+size\+\_\+in\+\_\+bytes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Let\textquotesingle{}s us know the size of the next \hyperlink{classral_1_1cache_1_1CacheData}{Cache\+Data} to be pulled. Sometimes it is useful to know how much data we will be pulling in each \hyperlink{classral_1_1cache_1_1CacheData}{Cache\+Data} that we have accumulated for making estimates on how much more is going to be coming or seeing how far along we are. \begin{DoxyReturn}{Returns}
The number of bytes consumed by the next message. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a8225fd0f55e72bf630f261def644d527}\label{classral_1_1cache_1_1WaitingQueue_a8225fd0f55e72bf630f261def644d527}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!get\+\_\+or\+\_\+wait@{get\+\_\+or\+\_\+wait}}
\index{get\+\_\+or\+\_\+wait@{get\+\_\+or\+\_\+wait}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{get\+\_\+or\+\_\+wait()}{get\_or\_wait()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
message\+\_\+ptr \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::get\+\_\+or\+\_\+wait (\begin{DoxyParamCaption}\item[{std\+::string}]{message\+\_\+id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Get a specific message from the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}. Messages are always accompanied by a message\+\_\+id though in some cases that id is empty string. This allows us to get a specific message from the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} and wait around for it to exist or for this \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} to be finished. If \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} is finished and there are no messages we get a nullptr. 
\begin{DoxyParams}{Parameters}
{\em message\+\_\+id} & The id of the message that we want to get or wait for. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The message that has this id or nullptr if that message will never be able to arrive because the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} is finished. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_ac365aaf9f942c2d5ac22087cbfaf5968}\label{classral_1_1cache_1_1WaitingQueue_ac365aaf9f942c2d5ac22087cbfaf5968}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!has\+\_\+next\+\_\+now@{has\+\_\+next\+\_\+now}}
\index{has\+\_\+next\+\_\+now@{has\+\_\+next\+\_\+now}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{has\+\_\+next\+\_\+now()}{has\_next\_now()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
bool \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::has\+\_\+next\+\_\+now (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Indicates if the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} has messages at this point in time. \begin{DoxyReturn}{Returns}
A bool which is true if the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} is not empty. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a33631ea402ae98a42b144bc3f1453341}\label{classral_1_1cache_1_1WaitingQueue_a33631ea402ae98a42b144bc3f1453341}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!is\+\_\+finished@{is\+\_\+finished}}
\index{is\+\_\+finished@{is\+\_\+finished}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{is\+\_\+finished()}{is\_finished()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
bool \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::is\+\_\+finished (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Lets us know if a \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} has finished running messages. \begin{DoxyReturn}{Returns}
A bool indicating whether or not this \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} is finished. receiving messages. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_ad5ef46c8b24d7de3f2a00c4e6f927e0a}\label{classral_1_1cache_1_1WaitingQueue_ad5ef46c8b24d7de3f2a00c4e6f927e0a}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!lock@{lock}}
\index{lock@{lock}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{lock()}{lock()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
std\+::unique\+\_\+lock$<$std\+::mutex$>$ \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::lock (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

A function that returns a unique\+\_\+lock using the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}\textquotesingle{}s mutex. \begin{DoxyReturn}{Returns}
A unique\+\_\+lock 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a259a82267567c6b5da96bd1bac53f6db}\label{classral_1_1cache_1_1WaitingQueue_a259a82267567c6b5da96bd1bac53f6db}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!pop\+\_\+back@{pop\+\_\+back}}
\index{pop\+\_\+back@{pop\+\_\+back}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{pop\+\_\+back()}{pop\_back()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
message\+\_\+ptr \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::pop\+\_\+back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Get a message\+\_\+ptr from the back of the queue if it exists in the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} else return nullptr. \begin{DoxyReturn}{Returns}
message\+\_\+ptr from the back of the queue if it exists in the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} else return nullptr. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_afbc5898a999bb8b5257c5de1b656db1c}\label{classral_1_1cache_1_1WaitingQueue_afbc5898a999bb8b5257c5de1b656db1c}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!pop\+\_\+or\+\_\+wait@{pop\+\_\+or\+\_\+wait}}
\index{pop\+\_\+or\+\_\+wait@{pop\+\_\+or\+\_\+wait}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{pop\+\_\+or\+\_\+wait()}{pop\_or\_wait()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
message\+\_\+ptr \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::pop\+\_\+or\+\_\+wait (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Get a message\+\_\+ptr if it exists in the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} else wait. This function allows kernels to pull from the cache before a cache has \hyperlink{classral_1_1cache_1_1CacheData}{Cache\+Data} in it. If finish is called on the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} and no messages are left this returns nullptr. \begin{DoxyReturn}{Returns}
A message\+\_\+ptr that was pushed into the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} nullptr if the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} is empty and finished. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a0ba9790cb2d41d01f7721b9972e4ff44}\label{classral_1_1cache_1_1WaitingQueue_a0ba9790cb2d41d01f7721b9972e4ff44}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!pop\+\_\+unsafe@{pop\+\_\+unsafe}}
\index{pop\+\_\+unsafe@{pop\+\_\+unsafe}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{pop\+\_\+unsafe()}{pop\_unsafe()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
message\+\_\+ptr \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::pop\+\_\+unsafe (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Pop the front element W\+I\+T\+H\+O\+UT thread safety. Allos us to pop from the front in situations where we have already acquired a unique\+\_\+lock on this \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}\textquotesingle{}s mutex. \begin{DoxyReturn}{Returns}
The first message in the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_af3afa691f12cfe644d86e8c1f99a31ec}\label{classral_1_1cache_1_1WaitingQueue_af3afa691f12cfe644d86e8c1f99a31ec}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!processed\+\_\+parts@{processed\+\_\+parts}}
\index{processed\+\_\+parts@{processed\+\_\+parts}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{processed\+\_\+parts()}{processed\_parts()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
int \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::processed\+\_\+parts (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Get number of partitions processed. \begin{DoxyReturn}{Returns}
number of partitions that have been inserted into this \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a8049784eaf2ca3f33b3ed9accd2222d2}\label{classral_1_1cache_1_1WaitingQueue_a8049784eaf2ca3f33b3ed9accd2222d2}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!put@{put}}
\index{put@{put}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{put()}{put()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
void \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::put (\begin{DoxyParamCaption}\item[{message\+\_\+ptr}]{item }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Put a message onto the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} using unique\+\_\+lock. This message aquires a unique\+\_\+lock and then pushes a message onto the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}. It then increments the processed count and notifies the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}\textquotesingle{}s condition variable. 
\begin{DoxyParams}{Parameters}
{\em item} & the message\+\_\+ptr being added to the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a1ac476114c34c127aee7c43907088bea}\label{classral_1_1cache_1_1WaitingQueue_a1ac476114c34c127aee7c43907088bea}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!put\+\_\+all\+\_\+unsafe@{put\+\_\+all\+\_\+unsafe}}
\index{put\+\_\+all\+\_\+unsafe@{put\+\_\+all\+\_\+unsafe}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{put\+\_\+all\+\_\+unsafe()}{put\_all\_unsafe()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
void \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::put\+\_\+all\+\_\+unsafe (\begin{DoxyParamCaption}\item[{std\+::vector$<$ message\+\_\+ptr $>$}]{messages }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Put a vector of messages onto the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} without locking. 
\begin{DoxyParams}{Parameters}
{\em messages} & A vector of messages that will be pushed into the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_abd7d9824f1b89ead2c937e1c6d64ba4f}\label{classral_1_1cache_1_1WaitingQueue_abd7d9824f1b89ead2c937e1c6d64ba4f}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!wait\+\_\+for\+\_\+count@{wait\+\_\+for\+\_\+count}}
\index{wait\+\_\+for\+\_\+count@{wait\+\_\+for\+\_\+count}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{wait\+\_\+for\+\_\+count()}{wait\_for\_count()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
void \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::wait\+\_\+for\+\_\+count (\begin{DoxyParamCaption}\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Blocks executing thread until a certain number messages are reached. We often want to block a thread from proceeding until a certain number ouf messages exist in the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue}. It also alerts us if we ever receive more messages than we expected. \mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a2849a6f841c2958aba489237a24ec0df}\label{classral_1_1cache_1_1WaitingQueue_a2849a6f841c2958aba489237a24ec0df}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!wait\+\_\+for\+\_\+next@{wait\+\_\+for\+\_\+next}}
\index{wait\+\_\+for\+\_\+next@{wait\+\_\+for\+\_\+next}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{wait\+\_\+for\+\_\+next()}{wait\_for\_next()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
bool \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::wait\+\_\+for\+\_\+next (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Wait for the next message to be ready. \begin{DoxyReturn}{Returns}
Waits for the next \hyperlink{classral_1_1cache_1_1CacheData}{Cache\+Data} to be available. Returns true when this is the case. Returns false if the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} is both finished and empty. 
\end{DoxyReturn}
\mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a008f9d8254330dff1e653bd41fe43d9a}\label{classral_1_1cache_1_1WaitingQueue_a008f9d8254330dff1e653bd41fe43d9a}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!wait\+\_\+until\+\_\+finished@{wait\+\_\+until\+\_\+finished}}
\index{wait\+\_\+until\+\_\+finished@{wait\+\_\+until\+\_\+finished}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{wait\+\_\+until\+\_\+finished()}{wait\_until\_finished()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
void \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::wait\+\_\+until\+\_\+finished (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Pauses a threads execution until this \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} has finished processing. Sometimes, like in the case of Joins, we might be waiting for a \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} to have finished before the next kernel can use the data it contains. \mbox{\Hypertarget{classral_1_1cache_1_1WaitingQueue_a84d4f711f11a11970b381b5b5c5d5662}\label{classral_1_1cache_1_1WaitingQueue_a84d4f711f11a11970b381b5b5c5d5662}} 
\index{ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}!wait\+\_\+until\+\_\+num\+\_\+bytes@{wait\+\_\+until\+\_\+num\+\_\+bytes}}
\index{wait\+\_\+until\+\_\+num\+\_\+bytes@{wait\+\_\+until\+\_\+num\+\_\+bytes}!ral\+::cache\+::\+Waiting\+Queue@{ral\+::cache\+::\+Waiting\+Queue}}
\subsubsection{\texorpdfstring{wait\+\_\+until\+\_\+num\+\_\+bytes()}{wait\_until\_num\_bytes()}}
{\footnotesize\ttfamily template$<$typename message\+\_\+ptr$>$ \\
void \hyperlink{classral_1_1cache_1_1WaitingQueue}{ral\+::cache\+::\+Waiting\+Queue}$<$ message\+\_\+ptr $>$\+::wait\+\_\+until\+\_\+num\+\_\+bytes (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{num\+\_\+bytes }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Waits until a certain number of bytes exist in the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} During some execution kernels it is better to wait for a certain amount of the total anticipated data to be available before processing the next batch. 
\begin{DoxyParams}{Parameters}
{\em num\+\_\+bytes} & The number of bytes that we will wait to exist in the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} unless the \hyperlink{classral_1_1cache_1_1WaitingQueue}{Waiting\+Queue} has already had finished() called. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/tom/\+Documents/programming/romulo\+\_\+blazingsql/blazingsql/engine/src/execution\+\_\+graph/logic\+\_\+controllers/Waiting\+Queue.\+h\end{DoxyCompactItemize}
