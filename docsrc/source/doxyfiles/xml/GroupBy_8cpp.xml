<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="GroupBy_8cpp" kind="file" language="C++">
    <compoundname>GroupBy.cpp</compoundname>
    <includes local="no">spdlog/spdlog.h</includes>
    <includes local="no">spdlog/async.h</includes>
    <includes local="no">spdlog/sinks/basic_file_sink.h</includes>
    <includes local="no">spdlog/sinks/stdout_color_sinks.h</includes>
    <includes refid="GroupBy_8h" local="yes">GroupBy.h</includes>
    <includes refid="expression__utils_8hpp" local="yes">parser/expression_utils.hpp</includes>
    <includes refid="CalciteExpressionParsing_8h" local="yes">CalciteExpressionParsing.h</includes>
    <includes refid="CodeTimer_8h" local="yes">CodeTimer.h</includes>
    <includes refid="primitives_8h" local="yes">distribution/primitives.h</includes>
    <includes refid="CommonOperations_8h" local="yes">utilities/CommonOperations.h</includes>
    <includes local="no">blazingdb/io/Util/StringUtil.h</includes>
    <includes refid="LogicalProject_8h" local="yes">execution_graph/logic_controllers/LogicalProject.h</includes>
    <includes local="no">regex</includes>
    <includes local="no">cudf/aggregation.hpp</includes>
    <includes local="no">cudf/sorting.hpp</includes>
    <includes local="no">cudf/replace.hpp</includes>
    <includes local="no">cudf/stream_compaction.hpp</includes>
    <includes local="no">cudf/filling.hpp</includes>
    <includes local="no">cudf/scalar/scalar_factories.hpp</includes>
    <includes local="no">cudf/reduction.hpp</includes>
    <incdepgraph>
      <node id="6473">
        <label>/home/tom/Documents/programming/romulo_blazingsql/blazingsql/engine/src/operators/GroupBy.cpp</label>
        <link refid="GroupBy_8cpp"/>
        <childnode refid="6474" relation="include">
        </childnode>
        <childnode refid="6475" relation="include">
        </childnode>
        <childnode refid="6476" relation="include">
        </childnode>
        <childnode refid="6477" relation="include">
        </childnode>
        <childnode refid="6478" relation="include">
        </childnode>
        <childnode refid="6502" relation="include">
        </childnode>
        <childnode refid="6503" relation="include">
        </childnode>
        <childnode refid="6504" relation="include">
        </childnode>
        <childnode refid="6506" relation="include">
        </childnode>
        <childnode refid="6508" relation="include">
        </childnode>
        <childnode refid="6510" relation="include">
        </childnode>
        <childnode refid="6511" relation="include">
        </childnode>
        <childnode refid="6512" relation="include">
        </childnode>
        <childnode refid="6499" relation="include">
        </childnode>
        <childnode refid="6513" relation="include">
        </childnode>
        <childnode refid="6514" relation="include">
        </childnode>
        <childnode refid="6515" relation="include">
        </childnode>
        <childnode refid="6516" relation="include">
        </childnode>
        <childnode refid="6517" relation="include">
        </childnode>
        <childnode refid="6518" relation="include">
        </childnode>
      </node>
      <node id="6513">
        <label>cudf/sorting.hpp</label>
      </node>
      <node id="6487">
        <label>execution_graph/logic_controllers/LogicPrimitives.h</label>
        <link refid="LogicPrimitives_8h_source"/>
        <childnode refid="6488" relation="include">
        </childnode>
        <childnode refid="6489" relation="include">
        </childnode>
        <childnode refid="6484" relation="include">
        </childnode>
        <childnode refid="6485" relation="include">
        </childnode>
        <childnode refid="6480" relation="include">
        </childnode>
        <childnode refid="6490" relation="include">
        </childnode>
        <childnode refid="6492" relation="include">
        </childnode>
      </node>
      <node id="6517">
        <label>cudf/scalar/scalar_factories.hpp</label>
      </node>
      <node id="6495">
        <label>cstdint</label>
      </node>
      <node id="6490">
        <label>execution_graph/logic_controllers/BlazingColumn.h</label>
        <link refid="BlazingColumn_8h_source"/>
        <childnode refid="6491" relation="include">
        </childnode>
        <childnode refid="6488" relation="include">
        </childnode>
        <childnode refid="6489" relation="include">
        </childnode>
        <childnode refid="6484" relation="include">
        </childnode>
        <childnode refid="6485" relation="include">
        </childnode>
        <childnode refid="6480" relation="include">
        </childnode>
      </node>
      <node id="6483">
        <label>transport/Node.h</label>
        <link refid="Node_8h_source"/>
        <childnode refid="6484" relation="include">
        </childnode>
        <childnode refid="6485" relation="include">
        </childnode>
      </node>
      <node id="6478">
        <label>GroupBy.h</label>
        <link refid="GroupBy_8h_source"/>
        <childnode refid="6479" relation="include">
        </childnode>
        <childnode refid="6485" relation="include">
        </childnode>
        <childnode refid="6480" relation="include">
        </childnode>
        <childnode refid="6486" relation="include">
        </childnode>
        <childnode refid="6487" relation="include">
        </childnode>
        <childnode refid="6499" relation="include">
        </childnode>
        <childnode refid="6500" relation="include">
        </childnode>
        <childnode refid="6501" relation="include">
        </childnode>
        <childnode refid="6491" relation="include">
        </childnode>
      </node>
      <node id="6485">
        <label>string</label>
      </node>
      <node id="6499">
        <label>cudf/aggregation.hpp</label>
      </node>
      <node id="6481">
        <label>map</label>
      </node>
      <node id="6515">
        <label>cudf/stream_compaction.hpp</label>
      </node>
      <node id="6512">
        <label>regex</label>
      </node>
      <node id="6506">
        <label>distribution/primitives.h</label>
        <link refid="primitives_8h_source"/>
        <childnode refid="6479" relation="include">
        </childnode>
        <childnode refid="6507" relation="include">
        </childnode>
        <childnode refid="6480" relation="include">
        </childnode>
        <childnode refid="6487" relation="include">
        </childnode>
      </node>
      <node id="6476">
        <label>spdlog/sinks/basic_file_sink.h</label>
      </node>
      <node id="6492">
        <label>BlazingHostTable.h</label>
        <link refid="BlazingHostTable_8h_source"/>
        <childnode refid="6480" relation="include">
        </childnode>
        <childnode refid="6485" relation="include">
        </childnode>
        <childnode refid="6484" relation="include">
        </childnode>
        <childnode refid="6493" relation="include">
        </childnode>
        <childnode refid="6494" relation="include">
        </childnode>
        <childnode refid="6496" relation="include">
        </childnode>
        <childnode refid="6487" relation="include">
        </childnode>
      </node>
      <node id="6479">
        <label>execution_graph//Context.h</label>
        <link refid="Context_8h_source"/>
        <childnode refid="6480" relation="include">
        </childnode>
        <childnode refid="6481" relation="include">
        </childnode>
        <childnode refid="6482" relation="include">
        </childnode>
        <childnode refid="6483" relation="include">
        </childnode>
      </node>
      <node id="6514">
        <label>cudf/replace.hpp</label>
      </node>
      <node id="6508">
        <label>utilities/CommonOperations.h</label>
        <link refid="CommonOperations_8h_source"/>
        <childnode refid="6485" relation="include">
        </childnode>
        <childnode refid="6480" relation="include">
        </childnode>
        <childnode refid="6487" relation="include">
        </childnode>
        <childnode refid="6509" relation="include">
        </childnode>
      </node>
      <node id="6474">
        <label>spdlog/spdlog.h</label>
      </node>
      <node id="6502">
        <label>parser/expression_utils.hpp</label>
        <link refid="expression__utils_8hpp_source"/>
        <childnode refid="6481" relation="include">
        </childnode>
        <childnode refid="6485" relation="include">
        </childnode>
        <childnode refid="6480" relation="include">
        </childnode>
        <childnode refid="6493" relation="include">
        </childnode>
        <childnode refid="6499" relation="include">
        </childnode>
      </node>
      <node id="6489">
        <label>cudf/table/table_view.hpp</label>
      </node>
      <node id="6501">
        <label>cudf/detail/aggregation/aggregation.hpp</label>
      </node>
      <node id="6486">
        <label>tuple</label>
      </node>
      <node id="6511">
        <label>execution_graph/logic_controllers/LogicalProject.h</label>
        <link refid="LogicalProject_8h_source"/>
        <childnode refid="6479" relation="include">
        </childnode>
        <childnode refid="6487" relation="include">
        </childnode>
        <childnode refid="6490" relation="include">
        </childnode>
      </node>
      <node id="6475">
        <label>spdlog/async.h</label>
      </node>
      <node id="6497">
        <label>stack</label>
      </node>
      <node id="6480">
        <label>vector</label>
      </node>
      <node id="6494">
        <label>transport/ColumnTransport.h</label>
        <link refid="ColumnTransport_8h_source"/>
        <childnode refid="6495" relation="include">
        </childnode>
      </node>
      <node id="6510">
        <label>blazingdb/io/Util/StringUtil.h</label>
      </node>
      <node id="6509">
        <label>cudf/column/column_factories.hpp</label>
      </node>
      <node id="6498">
        <label>ucp/api/ucp.h</label>
      </node>
      <node id="6516">
        <label>cudf/filling.hpp</label>
      </node>
      <node id="6477">
        <label>spdlog/sinks/stdout_color_sinks.h</label>
      </node>
      <node id="6496">
        <label>bmr/BufferProvider.h</label>
        <link refid="BufferProvider_8h_source"/>
        <childnode refid="6480" relation="include">
        </childnode>
        <childnode refid="6485" relation="include">
        </childnode>
        <childnode refid="6497" relation="include">
        </childnode>
        <childnode refid="6482" relation="include">
        </childnode>
        <childnode refid="6484" relation="include">
        </childnode>
        <childnode refid="6498" relation="include">
        </childnode>
      </node>
      <node id="6493">
        <label>cudf/types.hpp</label>
      </node>
      <node id="6518">
        <label>cudf/reduction.hpp</label>
      </node>
      <node id="6491">
        <label>cudf/column/column_view.hpp</label>
      </node>
      <node id="6482">
        <label>mutex</label>
      </node>
      <node id="6505">
        <label>chrono</label>
      </node>
      <node id="6503">
        <label>CalciteExpressionParsing.h</label>
        <link refid="CalciteExpressionParsing_8h_source"/>
        <childnode refid="6493" relation="include">
        </childnode>
        <childnode refid="6485" relation="include">
        </childnode>
        <childnode refid="6480" relation="include">
        </childnode>
      </node>
      <node id="6504">
        <label>CodeTimer.h</label>
        <link refid="CodeTimer_8h_source"/>
        <childnode refid="6505" relation="include">
        </childnode>
      </node>
      <node id="6488">
        <label>cudf/table/table.hpp</label>
      </node>
      <node id="6507">
        <label>communication/factory/MessageFactory.h</label>
        <link refid="MessageFactory_8h_source"/>
      </node>
      <node id="6500">
        <label>cudf/groupby.hpp</label>
      </node>
      <node id="6484">
        <label>memory</label>
      </node>
    </incdepgraph>
    <innernamespace refid="namespaceral">ral</innernamespace>
    <innernamespace refid="namespaceral_1_1operators">ral::operators</innernamespace>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <programlisting>
<codeline lineno="1"><highlight class="preprocessor">#include<sp/>&lt;spdlog/spdlog.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="2"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;spdlog/async.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="3"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;spdlog/sinks/basic_file_sink.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="4"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;spdlog/sinks/stdout_color_sinks.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="5"><highlight class="normal"></highlight></codeline>
<codeline lineno="6"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;GroupBy.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="7"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;parser/expression_utils.hpp&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="8"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;CalciteExpressionParsing.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="9"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;CodeTimer.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="10"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;distribution/primitives.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="11"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;utilities/CommonOperations.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="12"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;blazingdb/io/Util/StringUtil.h&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="13"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&quot;execution_graph/logic_controllers/LogicalProject.h&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="14"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;regex&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="15"><highlight class="normal"></highlight></codeline>
<codeline lineno="16"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cudf/aggregation.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="17"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cudf/sorting.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="18"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cudf/replace.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="19"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cudf/stream_compaction.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="20"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cudf/filling.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="21"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cudf/scalar/scalar_factories.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="22"><highlight class="normal"></highlight><highlight class="preprocessor">#include<sp/>&lt;cudf/reduction.hpp&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="23"><highlight class="normal"></highlight></codeline>
<codeline lineno="24"><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceral" kindref="compound">ral</ref><sp/>{</highlight></codeline>
<codeline lineno="25"><highlight class="normal"></highlight><highlight class="keyword">namespace<sp/></highlight><highlight class="normal">operators<sp/>{</highlight></codeline>
<codeline lineno="26"><highlight class="normal"></highlight></codeline>
<codeline lineno="27"><highlight class="normal"></highlight><highlight class="comment">//<sp/>TODO<sp/>all<sp/>these<sp/>return<sp/>types<sp/>need<sp/>to<sp/>be<sp/>revisited<sp/>later.<sp/>Right<sp/>now<sp/>we<sp/>have<sp/>issues<sp/>with<sp/>some<sp/>aggregators<sp/>that<sp/>only</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="28"><highlight class="normal"></highlight><highlight class="comment">//<sp/>support<sp/>returning<sp/>the<sp/>same<sp/>input<sp/>type.<sp/>Also<sp/>pygdf<sp/>does<sp/>not<sp/>currently<sp/>support<sp/>unsigned<sp/>types<sp/>(for<sp/>example<sp/>count<sp/>should</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="29"><highlight class="normal"></highlight><highlight class="comment">//<sp/>return<sp/>and<sp/>unsigned<sp/>type)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="30"><highlight class="normal">cudf::type_id<sp/>get_aggregation_output_type(cudf::type_id<sp/>input_type,<sp/>AggregateKind<sp/>aggregation,<sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>have_groupby)<sp/>{</highlight></codeline>
<codeline lineno="31"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::COUNT_VALID<sp/>||<sp/>aggregation<sp/>==<sp/>AggregateKind::COUNT_ALL)<sp/>{</highlight></codeline>
<codeline lineno="32"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::type_id::INT64;</highlight></codeline>
<codeline lineno="33"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::SUM<sp/>||<sp/>aggregation<sp/>==<sp/>AggregateKind::SUM0)<sp/>{</highlight></codeline>
<codeline lineno="34"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(have_groupby)</highlight></codeline>
<codeline lineno="35"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>input_type;<sp/><sp/></highlight><highlight class="comment">//<sp/>current<sp/>group<sp/>by<sp/>function<sp/>can<sp/>only<sp/>handle<sp/>this</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="36"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="37"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>we<sp/>can<sp/>assume<sp/>it<sp/>is<sp/>numeric<sp/>based<sp/>on<sp/>the<sp/>oepration</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="38"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>to<sp/>be<sp/>safe<sp/>we<sp/>should<sp/>enlarge<sp/>to<sp/>the<sp/>greatest<sp/>integer<sp/>or<sp/>float<sp/>representation</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="39"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>is_type_float(input_type)<sp/>?<sp/>cudf::type_id::FLOAT64<sp/>:<sp/>cudf::type_id::INT64;</highlight></codeline>
<codeline lineno="40"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="41"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::MIN)<sp/>{</highlight></codeline>
<codeline lineno="42"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>input_type;</highlight></codeline>
<codeline lineno="43"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::MAX)<sp/>{</highlight></codeline>
<codeline lineno="44"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>input_type;</highlight></codeline>
<codeline lineno="45"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::MEAN)<sp/>{</highlight></codeline>
<codeline lineno="46"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::type_id::FLOAT64;</highlight></codeline>
<codeline lineno="47"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::COUNT_DISTINCT)<sp/>{</highlight></codeline>
<codeline lineno="48"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Currently<sp/>this<sp/>conditional<sp/>is<sp/>unreachable.</highlight></codeline>
<codeline lineno="49"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Calcite<sp/>transforms<sp/>count<sp/>distincts<sp/>through<sp/>the</highlight></codeline>
<codeline lineno="50"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AggregateExpandDistinctAggregates<sp/>rule,<sp/>so<sp/>in<sp/>fact,</highlight></codeline>
<codeline lineno="51"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>each<sp/>count<sp/>distinct<sp/>is<sp/>replaced<sp/>by<sp/>some<sp/>group<sp/>by<sp/>clauses.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="52"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::type_id::INT64;</highlight></codeline>
<codeline lineno="53"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="54"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>std::runtime_error(</highlight></codeline>
<codeline lineno="55"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;In<sp/>get_aggregation_output_type<sp/>function:<sp/>aggregation<sp/>type<sp/>not<sp/>supported:<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>aggregation);</highlight></codeline>
<codeline lineno="56"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="57"><highlight class="normal">}</highlight></codeline>
<codeline lineno="58"><highlight class="normal"></highlight></codeline>
<codeline lineno="59"><highlight class="normal"></highlight><highlight class="comment">/*<sp/>Function<sp/>used<sp/>to<sp/>name<sp/>columns*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="60"><highlight class="normal">std::string<sp/>aggregator_to_string(AggregateKind<sp/>aggregation)<sp/>{</highlight></codeline>
<codeline lineno="61"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::COUNT_VALID<sp/>||<sp/>aggregation<sp/>==<sp/>AggregateKind::COUNT_ALL)<sp/>{</highlight></codeline>
<codeline lineno="62"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;count&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="63"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::SUM)<sp/>{</highlight></codeline>
<codeline lineno="64"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;sum&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="65"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::SUM0)<sp/>{</highlight></codeline>
<codeline lineno="66"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;sum0&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="67"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::MIN)<sp/>{</highlight></codeline>
<codeline lineno="68"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;min&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="69"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::MAX)<sp/>{</highlight></codeline>
<codeline lineno="70"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;max&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="71"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::MEAN)<sp/>{</highlight></codeline>
<codeline lineno="72"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;avg&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="73"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation<sp/>==<sp/>AggregateKind::COUNT_DISTINCT)<sp/>{</highlight></codeline>
<codeline lineno="74"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Currently<sp/>this<sp/>conditional<sp/>is<sp/>unreachable.</highlight></codeline>
<codeline lineno="75"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Calcite<sp/>transforms<sp/>count<sp/>distincts<sp/>through<sp/>the</highlight></codeline>
<codeline lineno="76"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AggregateExpandDistinctAggregates<sp/>rule,<sp/>so<sp/>in<sp/>fact,</highlight></codeline>
<codeline lineno="77"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>each<sp/>count<sp/>distinct<sp/>is<sp/>replaced<sp/>by<sp/>some<sp/>group<sp/>by<sp/>clauses.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="78"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;count_distinct&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="79"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="80"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal">;<sp/><sp/></highlight><highlight class="comment">//<sp/>FIXME:<sp/>is<sp/>really<sp/>necessary?</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="81"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="82"><highlight class="normal">}</highlight></codeline>
<codeline lineno="83"><highlight class="normal"></highlight></codeline>
<codeline lineno="84"><highlight class="normal">AggregateKind<sp/>get_aggregation_operation(std::string<sp/>expression_in)<sp/>{</highlight></codeline>
<codeline lineno="85"><highlight class="normal"></highlight></codeline>
<codeline lineno="86"><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>operator_string<sp/>=<sp/>get_aggregation_operation_string(expression_in);</highlight></codeline>
<codeline lineno="87"><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>expression<sp/>=<sp/>get_string_between_outer_parentheses(expression_in);</highlight></codeline>
<codeline lineno="88"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(expression<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/>operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;COUNT&quot;</highlight><highlight class="normal">){</highlight></codeline>
<codeline lineno="89"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::COUNT_ALL;</highlight></codeline>
<codeline lineno="90"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;SUM&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="91"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::SUM;</highlight></codeline>
<codeline lineno="92"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;$SUM0&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="93"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::SUM0;</highlight></codeline>
<codeline lineno="94"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;AVG&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="95"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::MEAN;</highlight></codeline>
<codeline lineno="96"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;MIN&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="97"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::MIN;</highlight></codeline>
<codeline lineno="98"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;MAX&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="99"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::MAX;</highlight></codeline>
<codeline lineno="100"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;ROW_NUMBER&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="101"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::ROW_NUMBER;</highlight></codeline>
<codeline lineno="102"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;COUNT&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="103"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::COUNT_VALID;</highlight></codeline>
<codeline lineno="104"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;LEAD&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="105"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::LEAD;</highlight></codeline>
<codeline lineno="106"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;LAG&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="107"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::LAG;</highlight></codeline>
<codeline lineno="108"><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(operator_string<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;COUNT_DISTINCT&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="109"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Currently<sp/>this<sp/>conditional<sp/>is<sp/>unreachable.</highlight></codeline>
<codeline lineno="110"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Calcite<sp/>transforms<sp/>count<sp/>distincts<sp/>through<sp/>the</highlight></codeline>
<codeline lineno="111"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AggregateExpandDistinctAggregates<sp/>rule,<sp/>so<sp/>in<sp/>fact,</highlight></codeline>
<codeline lineno="112"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>each<sp/>count<sp/>distinct<sp/>is<sp/>replaced<sp/>by<sp/>some<sp/>group<sp/>by<sp/>clauses.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="113"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>AggregateKind::COUNT_DISTINCT;</highlight></codeline>
<codeline lineno="114"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="115"><highlight class="normal"></highlight></codeline>
<codeline lineno="116"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>std::runtime_error(</highlight></codeline>
<codeline lineno="117"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;In<sp/>get_aggregation_operation<sp/>function:<sp/>aggregation<sp/>type<sp/>not<sp/>supported,<sp/>&quot;</highlight><highlight class="normal"><sp/>+<sp/>operator_string);</highlight></codeline>
<codeline lineno="118"><highlight class="normal">}</highlight></codeline>
<codeline lineno="119"><highlight class="normal"></highlight></codeline>
<codeline lineno="120"><highlight class="normal">std::unique_ptr&lt;cudf::aggregation&gt;<sp/>makeCudfAggregation(AggregateKind<sp/>input,<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>offset){</highlight></codeline>
<codeline lineno="121"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::SUM){</highlight></codeline>
<codeline lineno="122"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_sum_aggregation();</highlight></codeline>
<codeline lineno="123"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::MEAN){</highlight></codeline>
<codeline lineno="124"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_mean_aggregation();</highlight></codeline>
<codeline lineno="125"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::MIN){</highlight></codeline>
<codeline lineno="126"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_min_aggregation();</highlight></codeline>
<codeline lineno="127"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::MAX){</highlight></codeline>
<codeline lineno="128"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_max_aggregation();</highlight></codeline>
<codeline lineno="129"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::ROW_NUMBER)<sp/>{</highlight></codeline>
<codeline lineno="130"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_row_number_aggregation();</highlight></codeline>
<codeline lineno="131"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::COUNT_VALID){</highlight></codeline>
<codeline lineno="132"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_count_aggregation(cudf::null_policy::EXCLUDE);</highlight></codeline>
<codeline lineno="133"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::COUNT_ALL){</highlight></codeline>
<codeline lineno="134"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_count_aggregation(cudf::null_policy::INCLUDE);</highlight></codeline>
<codeline lineno="135"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::SUM0){</highlight></codeline>
<codeline lineno="136"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_sum_aggregation();</highlight></codeline>
<codeline lineno="137"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::LAG){</highlight></codeline>
<codeline lineno="138"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_lag_aggregation(offset);<sp/><sp/></highlight></codeline>
<codeline lineno="139"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::LEAD){</highlight></codeline>
<codeline lineno="140"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_lead_aggregation(offset);<sp/></highlight></codeline>
<codeline lineno="141"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(input<sp/>==<sp/>AggregateKind::COUNT_DISTINCT){</highlight></codeline>
<codeline lineno="142"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">/*<sp/>Currently<sp/>this<sp/>conditional<sp/>is<sp/>unreachable.</highlight></codeline>
<codeline lineno="143"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>Calcite<sp/>transforms<sp/>count<sp/>distincts<sp/>through<sp/>the</highlight></codeline>
<codeline lineno="144"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>AggregateExpandDistinctAggregates<sp/>rule,<sp/>so<sp/>in<sp/>fact,</highlight></codeline>
<codeline lineno="145"><highlight class="comment"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>each<sp/>count<sp/>distinct<sp/>is<sp/>replaced<sp/>by<sp/>some<sp/>group<sp/>by<sp/>clauses.<sp/>*/</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="146"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>cudf::make_nunique_aggregation();</highlight></codeline>
<codeline lineno="147"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="148"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">throw</highlight><highlight class="normal"><sp/>std::runtime_error(</highlight></codeline>
<codeline lineno="149"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;In<sp/>makeCudfAggregation<sp/>function:<sp/>AggregateKind<sp/>type<sp/>not<sp/>supported&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="150"><highlight class="normal">}</highlight></codeline>
<codeline lineno="151"><highlight class="normal"></highlight></codeline>
<codeline lineno="152"><highlight class="normal">std::vector&lt;int&gt;<sp/>get_group_columns(std::string<sp/>query_part)<sp/>{</highlight></codeline>
<codeline lineno="153"><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>temp_column_string<sp/>=<sp/>get_named_expression(query_part,<sp/></highlight><highlight class="stringliteral">&quot;group&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="154"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(temp_column_string.size()<sp/>&lt;=<sp/>2)<sp/>{</highlight></codeline>
<codeline lineno="155"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::vector&lt;int&gt;();</highlight></codeline>
<codeline lineno="156"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="157"><highlight class="normal"></highlight></codeline>
<codeline lineno="158"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Now<sp/>we<sp/>have<sp/>somethig<sp/>like<sp/>{0,<sp/>1}</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="159"><highlight class="normal"><sp/><sp/><sp/><sp/>temp_column_string<sp/>=<sp/>temp_column_string.substr(1,<sp/>temp_column_string.length()<sp/>-<sp/>2);</highlight></codeline>
<codeline lineno="160"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>column_numbers_string<sp/>=<sp/>StringUtil::split(temp_column_string,<sp/></highlight><highlight class="stringliteral">&quot;,&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="161"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;int&gt;<sp/>group_column_indices(column_numbers_string.size());</highlight></codeline>
<codeline lineno="162"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>column_numbers_string.size();<sp/>i++)<sp/>{</highlight></codeline>
<codeline lineno="163"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>group_column_indices[i]<sp/>=<sp/>std::stoull(column_numbers_string[i],<sp/>0);</highlight></codeline>
<codeline lineno="164"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="165"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>group_column_indices;</highlight></codeline>
<codeline lineno="166"><highlight class="normal">}</highlight></codeline>
<codeline lineno="167"><highlight class="normal"></highlight></codeline>
<codeline lineno="168"><highlight class="normal">std::tuple&lt;std::vector&lt;int&gt;,<sp/>std::vector&lt;std::string&gt;,<sp/>std::vector&lt;AggregateKind&gt;,std::vector&lt;std::string&gt;&gt;</highlight></codeline>
<codeline lineno="169"><highlight class="normal"><sp/><sp/><sp/><sp/>parseGroupByExpression(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::string<sp/>&amp;<sp/>queryString,<sp/>std::size_t<sp/>num_cols){</highlight></codeline>
<codeline lineno="170"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;AggregateKind&gt;<sp/>aggregation_types;</highlight></codeline>
<codeline lineno="171"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>aggregation_input_expressions;</highlight></codeline>
<codeline lineno="172"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;int&gt;<sp/>group_column_indices;</highlight></codeline>
<codeline lineno="173"><highlight class="normal"></highlight></codeline>
<codeline lineno="174"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Get<sp/>aggregations</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="175"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>aggregation_expressions;</highlight></codeline>
<codeline lineno="176"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>aggregation_column_assigned_aliases;</highlight></codeline>
<codeline lineno="177"><highlight class="normal"></highlight></codeline>
<codeline lineno="178"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rangeStart<sp/>=<sp/>queryString.find(</highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="179"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>rangeEnd<sp/>=<sp/>queryString.rfind(</highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">)<sp/>-<sp/>rangeStart;</highlight></codeline>
<codeline lineno="180"><highlight class="normal"><sp/><sp/><sp/><sp/>std::string<sp/>combined_expression<sp/>=<sp/>queryString.substr(rangeStart<sp/>+<sp/>1,<sp/>rangeEnd<sp/>-<sp/>1);</highlight></codeline>
<codeline lineno="181"><highlight class="normal"></highlight></codeline>
<codeline lineno="182"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>in<sp/>case<sp/>UNION<sp/>exists,</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="183"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(combined_expression<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;group=[{*}]&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="184"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>StringUtil::findAndReplaceAll(combined_expression,<sp/></highlight><highlight class="stringliteral">&quot;*&quot;</highlight><highlight class="normal">,<sp/>StringUtil::makeCommaDelimitedSequence(num_cols));</highlight></codeline>
<codeline lineno="185"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="186"><highlight class="normal"></highlight></codeline>
<codeline lineno="187"><highlight class="normal"><sp/><sp/><sp/><sp/>group_column_indices<sp/>=<sp/>get_group_columns(combined_expression);</highlight></codeline>
<codeline lineno="188"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>expressions<sp/>=<sp/>get_expressions_from_expression_list(combined_expression);</highlight></codeline>
<codeline lineno="189"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::string<sp/>expr<sp/>:<sp/>expressions)<sp/>{</highlight></codeline>
<codeline lineno="190"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::string<sp/>expression<sp/>=<sp/>std::regex_replace(expr,<sp/>std::regex(</highlight><highlight class="stringliteral">&quot;^<sp/>+|<sp/>+$|(<sp/>)<sp/>+&quot;</highlight><highlight class="normal">),<sp/></highlight><highlight class="stringliteral">&quot;$1&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="191"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(expression.find(</highlight><highlight class="stringliteral">&quot;group=&quot;</highlight><highlight class="normal">)<sp/>==<sp/>std::string::npos)<sp/>{</highlight></codeline>
<codeline lineno="192"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_expressions.push_back(expression);</highlight></codeline>
<codeline lineno="193"><highlight class="normal"></highlight></codeline>
<codeline lineno="194"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>the<sp/>aggregation<sp/>has<sp/>an<sp/>alias,<sp/>lets<sp/>capture<sp/>it<sp/>here,<sp/>otherwise<sp/>we&apos;ll<sp/>figure<sp/>out<sp/>what<sp/>to<sp/>call<sp/>the</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="195"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>aggregation<sp/>based<sp/>on<sp/>its<sp/>input</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="196"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(expression.find(</highlight><highlight class="stringliteral">&quot;EXPR$&quot;</highlight><highlight class="normal">)<sp/>==<sp/>0)</highlight></codeline>
<codeline lineno="197"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_column_assigned_aliases.push_back(</highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="198"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="199"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_column_assigned_aliases.push_back(expression.substr(0,<sp/>expression.find(</highlight><highlight class="stringliteral">&quot;=[&quot;</highlight><highlight class="normal">)));</highlight></codeline>
<codeline lineno="200"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="201"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="202"><highlight class="normal"></highlight></codeline>
<codeline lineno="203"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(std::string<sp/>expression<sp/>:<sp/>aggregation_expressions)<sp/>{</highlight></codeline>
<codeline lineno="204"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_types.push_back(get_aggregation_operation(expression));</highlight></codeline>
<codeline lineno="205"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_input_expressions.push_back(get_string_between_outer_parentheses(expression));</highlight></codeline>
<codeline lineno="206"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="207"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_tuple(std::move(group_column_indices),<sp/>std::move(aggregation_input_expressions),</highlight></codeline>
<codeline lineno="208"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::move(aggregation_types),<sp/>std::move(aggregation_column_assigned_aliases));</highlight></codeline>
<codeline lineno="209"><highlight class="normal">}</highlight></codeline>
<codeline lineno="210"><highlight class="normal"></highlight></codeline>
<codeline lineno="211"><highlight class="normal"></highlight></codeline>
<codeline lineno="212"><highlight class="normal">std::tuple&lt;std::vector&lt;int&gt;,<sp/>std::vector&lt;std::string&gt;,<sp/>std::vector&lt;AggregateKind&gt;,<sp/><sp/>std::vector&lt;std::string&gt;&gt;</highlight></codeline>
<codeline lineno="213"><highlight class="normal"><sp/><sp/><sp/><sp/>modGroupByParametersPostComputeAggregations(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;int&gt;<sp/>&amp;<sp/>group_column_indices,</highlight></codeline>
<codeline lineno="214"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;AggregateKind&gt;<sp/>&amp;<sp/>aggregation_types,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;std::string&gt;<sp/>&amp;<sp/>merging_column_names)<sp/>{</highlight></codeline>
<codeline lineno="215"><highlight class="normal"></highlight></codeline>
<codeline lineno="216"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;AggregateKind&gt;<sp/>mod_aggregation_types<sp/>=<sp/>aggregation_types;</highlight></codeline>
<codeline lineno="217"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>mod_aggregation_input_expressions(aggregation_types.size());</highlight></codeline>
<codeline lineno="218"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>mod_aggregation_column_assigned_aliases(mod_aggregation_types.size());</highlight></codeline>
<codeline lineno="219"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;int&gt;<sp/>mod_group_column_indices(group_column_indices.size());</highlight></codeline>
<codeline lineno="220"><highlight class="normal"><sp/><sp/><sp/><sp/>std::iota(mod_group_column_indices.begin(),<sp/>mod_group_column_indices.end(),<sp/>0);</highlight></codeline>
<codeline lineno="221"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>mod_aggregation_types.size();<sp/>i++){</highlight></codeline>
<codeline lineno="222"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(mod_aggregation_types[i]<sp/>==<sp/>AggregateKind::COUNT_ALL<sp/>||<sp/>mod_aggregation_types[i]<sp/>==<sp/>AggregateKind::COUNT_VALID){</highlight></codeline>
<codeline lineno="223"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mod_aggregation_types[i]<sp/>=<sp/>AggregateKind::SUM;<sp/></highlight><highlight class="comment">//<sp/>if<sp/>we<sp/>have<sp/>a<sp/>COUNT,<sp/>we<sp/>want<sp/>to<sp/>SUM<sp/>the<sp/>output<sp/>of<sp/>the<sp/>counts<sp/>from<sp/>other<sp/>nodes</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="224"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="225"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mod_aggregation_input_expressions[i]<sp/>=<sp/>std::to_string(i<sp/>+<sp/>mod_group_column_indices.size());<sp/></highlight><highlight class="comment">//<sp/>we<sp/>just<sp/>want<sp/>to<sp/>aggregate<sp/>the<sp/>input<sp/>columns,<sp/>so<sp/>we<sp/>are<sp/>setting<sp/>the<sp/>indices<sp/>here</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="226"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>mod_aggregation_column_assigned_aliases[i]<sp/>=<sp/>merging_column_names[i<sp/>+<sp/>mod_group_column_indices.size()];</highlight></codeline>
<codeline lineno="227"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="228"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_tuple(std::move(mod_group_column_indices),<sp/>std::move(mod_aggregation_input_expressions),</highlight></codeline>
<codeline lineno="229"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::move(mod_aggregation_types),<sp/>std::move(mod_aggregation_column_assigned_aliases));</highlight></codeline>
<codeline lineno="230"><highlight class="normal">}</highlight></codeline>
<codeline lineno="231"><highlight class="normal"></highlight></codeline>
<codeline lineno="232"><highlight class="normal"></highlight><highlight class="keyword">using<sp/>namespace<sp/></highlight><highlight class="normal"><ref refid="namespaceral_1_1distribution" kindref="compound">ral::distribution</ref>;</highlight></codeline>
<codeline lineno="233"><highlight class="normal"></highlight></codeline>
<codeline lineno="234"><highlight class="normal">std::unique_ptr&lt;ral::frame::BlazingTable&gt;<sp/>compute_groupby_without_aggregations(</highlight></codeline>
<codeline lineno="235"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classral_1_1frame_1_1BlazingTableView" kindref="compound">ral::frame::BlazingTableView</ref><sp/>&amp;<sp/>table,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;int&gt;<sp/>&amp;<sp/>group_column_indices)<sp/>{</highlight></codeline>
<codeline lineno="236"><highlight class="normal"></highlight></codeline>
<codeline lineno="237"><highlight class="normal"><sp/><sp/><sp/><sp/>std::unique_ptr&lt;cudf::table&gt;<sp/>output<sp/>=<sp/>cudf::drop_duplicates(table.view(),</highlight></codeline>
<codeline lineno="238"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>group_column_indices,</highlight></codeline>
<codeline lineno="239"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudf::duplicate_keep_option::KEEP_FIRST);</highlight></codeline>
<codeline lineno="240"><highlight class="normal"></highlight></codeline>
<codeline lineno="241"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_unique&lt;ral::frame::BlazingTable&gt;(<sp/>std::move(output),<sp/>table.names()<sp/>);</highlight></codeline>
<codeline lineno="242"><highlight class="normal">}</highlight></codeline>
<codeline lineno="243"><highlight class="normal"></highlight></codeline>
<codeline lineno="244"><highlight class="normal">std::unique_ptr&lt;ral::frame::BlazingTable&gt;<sp/>compute_aggregations_without_groupby(</highlight></codeline>
<codeline lineno="245"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classral_1_1frame_1_1BlazingTableView" kindref="compound">ral::frame::BlazingTableView</ref><sp/>&amp;<sp/>table,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;std::string&gt;<sp/>&amp;<sp/>aggregation_input_expressions,</highlight></codeline>
<codeline lineno="246"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;AggregateKind&gt;<sp/>&amp;<sp/>aggregation_types,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;std::string&gt;<sp/>&amp;<sp/>aggregation_column_assigned_aliases){</highlight></codeline>
<codeline lineno="247"><highlight class="normal"></highlight></codeline>
<codeline lineno="248"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::unique_ptr&lt;cudf::scalar&gt;&gt;<sp/>reductions;</highlight></codeline>
<codeline lineno="249"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>agg_output_column_names;</highlight></codeline>
<codeline lineno="250"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>aggregation_types.size();<sp/>i++){</highlight></codeline>
<codeline lineno="251"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation_input_expressions[i]<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/>aggregation_types[i]<sp/>==<sp/>AggregateKind::COUNT_ALL)<sp/>{<sp/></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>a<sp/>COUNT(*)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="252"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::unique_ptr&lt;cudf::scalar&gt;<sp/>scalar<sp/>=<sp/>cudf::make_numeric_scalar(cudf::data_type(cudf::type_id::INT64));</highlight></codeline>
<codeline lineno="253"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>numeric_s<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal"><sp/>cudf::scalar_type_t&lt;int64_t&gt;*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(scalar.get());</highlight></codeline>
<codeline lineno="254"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>numeric_s-&gt;set_value((int64_t)(table.view().num_rows()));</highlight></codeline>
<codeline lineno="255"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reductions.emplace_back(std::move(scalar));</highlight></codeline>
<codeline lineno="256"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="257"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;std::unique_ptr&lt;ral::frame::BlazingColumn&gt;&gt;<sp/>aggregation_input_scope_holder;</highlight></codeline>
<codeline lineno="258"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CudfColumnView<sp/>aggregation_input;</highlight></codeline>
<codeline lineno="259"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(is_var_column(aggregation_input_expressions[i])<sp/>||<sp/>is_number(aggregation_input_expressions[i]))<sp/>{</highlight></codeline>
<codeline lineno="260"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_input<sp/>=<sp/>table.view().column(get_index(aggregation_input_expressions[i]));</highlight></codeline>
<codeline lineno="261"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="262"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_input_scope_holder<sp/>=<sp/>ral::processor::evaluate_expressions(table.view(),<sp/>{aggregation_input_expressions[i]});</highlight></codeline>
<codeline lineno="263"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_input<sp/>=<sp/>aggregation_input_scope_holder[0]-&gt;view();</highlight></codeline>
<codeline lineno="264"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="265"><highlight class="normal"></highlight></codeline>
<codeline lineno="266"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(<sp/>aggregation_types[i]<sp/>==<sp/>AggregateKind::COUNT_VALID)<sp/>{</highlight></codeline>
<codeline lineno="267"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::unique_ptr&lt;cudf::scalar&gt;<sp/>scalar<sp/>=<sp/>cudf::make_numeric_scalar(cudf::data_type(cudf::type_id::INT64));</highlight></codeline>
<codeline lineno="268"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>numeric_s<sp/>=<sp/></highlight><highlight class="keyword">static_cast&lt;</highlight><highlight class="normal"><sp/>cudf::scalar_type_t&lt;int64_t&gt;*<sp/></highlight><highlight class="keyword">&gt;</highlight><highlight class="normal">(scalar.get());</highlight></codeline>
<codeline lineno="269"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>numeric_s-&gt;set_value((int64_t)(aggregation_input.size()<sp/>-<sp/>aggregation_input.null_count()));</highlight></codeline>
<codeline lineno="270"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reductions.emplace_back(std::move(scalar));</highlight></codeline>
<codeline lineno="271"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="272"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::unique_ptr&lt;cudf::aggregation&gt;<sp/>agg<sp/>=<sp/>makeCudfAggregation(aggregation_types[i]);</highlight></codeline>
<codeline lineno="273"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>cudf::type_id<sp/>output_type<sp/>=<sp/>get_aggregation_output_type(aggregation_input.type().id(),<sp/>aggregation_types[i],<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="274"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::unique_ptr&lt;cudf::scalar&gt;<sp/>reduction_out<sp/>=<sp/>cudf::reduce(aggregation_input,<sp/>agg,<sp/>cudf::data_type(output_type));</highlight></codeline>
<codeline lineno="275"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(aggregation_types[i]<sp/>==<sp/>AggregateKind::SUM0<sp/>&amp;&amp;<sp/>!reduction_out-&gt;is_valid()){<sp/></highlight><highlight class="comment">//<sp/>if<sp/>this<sp/>aggregation<sp/>was<sp/>a<sp/>SUM0,<sp/>and<sp/>it<sp/>was<sp/>not<sp/>valid,<sp/>we<sp/>want<sp/>it<sp/>to<sp/>be<sp/>a<sp/>valid<sp/>0<sp/>instead</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="276"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::unique_ptr&lt;cudf::scalar&gt;<sp/>zero_scalar<sp/>=<sp/>get_scalar_from_string(</highlight><highlight class="stringliteral">&quot;0&quot;</highlight><highlight class="normal">,<sp/>reduction_out-&gt;type());<sp/></highlight><highlight class="comment">//<sp/>this<sp/>does<sp/>not<sp/>need<sp/>to<sp/>be<sp/>from<sp/>a<sp/>string,<sp/>but<sp/>this<sp/>is<sp/>a<sp/>convenient<sp/>way<sp/>to<sp/>make<sp/>the<sp/>scalar<sp/>i<sp/>need</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="277"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reductions.emplace_back(std::move(zero_scalar));</highlight></codeline>
<codeline lineno="278"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="279"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>reductions.emplace_back(std::move(reduction_out));</highlight></codeline>
<codeline lineno="280"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="281"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="282"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="283"><highlight class="normal"></highlight></codeline>
<codeline lineno="284"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>the<sp/>aggregation<sp/>was<sp/>given<sp/>an<sp/>alias<sp/>lets<sp/>use<sp/>it,<sp/>otherwise<sp/>we&apos;ll<sp/>name<sp/>it<sp/>based<sp/>on<sp/>the<sp/>aggregation<sp/>and<sp/>input</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="285"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation_column_assigned_aliases[i]<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="286"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation_input_expressions[i]<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/>aggregation_types[i]<sp/>==<sp/>AggregateKind::COUNT_ALL)<sp/>{<sp/></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>a<sp/>COUNT(*)</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="287"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>agg_output_column_names.push_back(aggregator_to_string(aggregation_types[i])<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;(*)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="288"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="289"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>agg_output_column_names.push_back(aggregator_to_string(aggregation_types[i])<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>+<sp/>table.names().at(get_index(aggregation_input_expressions[i]))<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="290"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="291"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="292"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>agg_output_column_names.push_back(aggregation_column_assigned_aliases[i]);</highlight></codeline>
<codeline lineno="293"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="294"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="295"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>convert<sp/>scalars<sp/>into<sp/>columns</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="296"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::unique_ptr&lt;cudf::column&gt;&gt;<sp/>output_columns;</highlight></codeline>
<codeline lineno="297"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>reductions.size();<sp/>i++){</highlight></codeline>
<codeline lineno="298"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::unique_ptr&lt;cudf::column&gt;<sp/>temp<sp/>=<sp/>cudf::make_column_from_scalar(*(reductions[i]),<sp/>1);</highlight></codeline>
<codeline lineno="299"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_columns.emplace_back(std::move(temp));</highlight></codeline>
<codeline lineno="300"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="301"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_unique&lt;ral::frame::BlazingTable&gt;(std::move(std::make_unique&lt;CudfTable&gt;(std::move(output_columns))),<sp/>agg_output_column_names);</highlight></codeline>
<codeline lineno="302"><highlight class="normal">}</highlight></codeline>
<codeline lineno="303"><highlight class="normal"></highlight></codeline>
<codeline lineno="304"><highlight class="normal">std::unique_ptr&lt;ral::frame::BlazingTable&gt;<sp/>compute_aggregations_with_groupby(</highlight></codeline>
<codeline lineno="305"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="classral_1_1frame_1_1BlazingTableView" kindref="compound">ral::frame::BlazingTableView</ref><sp/>&amp;<sp/>table,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;std::string&gt;<sp/>&amp;<sp/>aggregation_input_expressions,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;AggregateKind&gt;<sp/>&amp;<sp/>aggregation_types,</highlight></codeline>
<codeline lineno="306"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;std::string&gt;<sp/>&amp;<sp/>aggregation_column_assigned_aliases,<sp/></highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/>std::vector&lt;int&gt;<sp/>&amp;<sp/>group_column_indices)<sp/>{</highlight></codeline>
<codeline lineno="307"><highlight class="normal"></highlight></codeline>
<codeline lineno="308"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>lets<sp/>get<sp/>the<sp/>unique<sp/>expressions.<sp/>This<sp/>is<sp/>how<sp/>many<sp/>aggregation<sp/>requests<sp/>we<sp/>will<sp/>need</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="309"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>unique_expressions<sp/>=<sp/>aggregation_input_expressions;</highlight></codeline>
<codeline lineno="310"><highlight class="normal"><sp/><sp/><sp/><sp/>std::sort(<sp/>unique_expressions.begin(),<sp/>unique_expressions.end()<sp/>);</highlight></codeline>
<codeline lineno="311"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>it<sp/>=<sp/>std::unique(<sp/>unique_expressions.begin(),<sp/>unique_expressions.end()<sp/>);</highlight></codeline>
<codeline lineno="312"><highlight class="normal"><sp/><sp/><sp/><sp/>unique_expressions.resize(<sp/>std::distance(unique_expressions.begin(),it)<sp/>);</highlight></codeline>
<codeline lineno="313"><highlight class="normal"></highlight></codeline>
<codeline lineno="314"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>will<sp/>iterate<sp/>over<sp/>the<sp/>unique<sp/>expressions<sp/>and<sp/>create<sp/>an<sp/>aggregation<sp/>request<sp/>for<sp/>each<sp/>one.</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="315"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>We<sp/>do<sp/>it<sp/>this<sp/>way,<sp/>because<sp/>you<sp/>could<sp/>have<sp/>something<sp/>like<sp/>min(colA),<sp/>max(colA),<sp/>sum(colA).</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="316"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>These<sp/>three<sp/>aggregations<sp/>would<sp/>all<sp/>be<sp/>in<sp/>one<sp/>request<sp/>because<sp/>they<sp/>have<sp/>the<sp/>same<sp/>input</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="317"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;<sp/>std::unique_ptr&lt;ral::frame::BlazingColumn&gt;<sp/>&gt;<sp/>aggregation_inputs_scope_holder;</highlight></codeline>
<codeline lineno="318"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;cudf::groupby::aggregation_request&gt;<sp/>requests;</highlight></codeline>
<codeline lineno="319"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;int&gt;<sp/>agg_out_indices;</highlight></codeline>
<codeline lineno="320"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>agg_output_column_names;</highlight></codeline>
<codeline lineno="321"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>u<sp/>=<sp/>0;<sp/>u<sp/>&lt;<sp/>unique_expressions.size();<sp/>u++){</highlight></codeline>
<codeline lineno="322"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::string<sp/>expression<sp/>=<sp/>unique_expressions[u];</highlight></codeline>
<codeline lineno="323"><highlight class="normal"></highlight></codeline>
<codeline lineno="324"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>CudfColumnView<sp/>aggregation_input;<sp/></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>the<sp/>input<sp/>from<sp/>which<sp/>we<sp/>will<sp/>crete<sp/>the<sp/>aggregation<sp/>request</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="325"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>got_aggregation_input<sp/>=<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="326"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;std::unique_ptr&lt;cudf::aggregation&gt;&gt;<sp/>agg_ops_for_request;</highlight></codeline>
<codeline lineno="327"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>aggregation_input_expressions.size();<sp/>i++){</highlight></codeline>
<codeline lineno="328"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(expression<sp/>==<sp/>aggregation_input_expressions[i]){</highlight></codeline>
<codeline lineno="329"><highlight class="normal"></highlight></codeline>
<codeline lineno="330"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>column_index<sp/>=<sp/>-1;</highlight></codeline>
<codeline lineno="331"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>need<sp/>to<sp/>calculate<sp/>or<sp/>determine<sp/>the<sp/>aggregation<sp/>input<sp/>only<sp/>once</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="332"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!got_aggregation_input)<sp/>{</highlight></codeline>
<codeline lineno="333"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(expression<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/>aggregation_types[i]<sp/>==<sp/>AggregateKind::COUNT_ALL<sp/>)<sp/>{<sp/></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>COUNT(*).<sp/>Lets<sp/>just<sp/>pick<sp/>the<sp/>first<sp/>column</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="334"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_input<sp/>=<sp/>table.view().column(0);</highlight></codeline>
<codeline lineno="335"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(is_var_column(expression)<sp/>||<sp/>is_number(expression))<sp/>{</highlight></codeline>
<codeline lineno="336"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>column_index<sp/>=<sp/>get_index(expression);</highlight></codeline>
<codeline lineno="337"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_input<sp/>=<sp/>table.view().column(column_index);</highlight></codeline>
<codeline lineno="338"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="339"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::vector&lt;<sp/>std::unique_ptr&lt;ral::frame::BlazingColumn&gt;<sp/>&gt;<sp/>computed_columns<sp/>=<sp/>ral::processor::evaluate_expressions(table.view(),<sp/>{expression});</highlight></codeline>
<codeline lineno="340"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_inputs_scope_holder.insert(aggregation_inputs_scope_holder.end(),<sp/>std::make_move_iterator(computed_columns.begin()),<sp/>std::make_move_iterator(computed_columns.end()));</highlight></codeline>
<codeline lineno="341"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>aggregation_input<sp/>=<sp/>aggregation_inputs_scope_holder.back()-&gt;view();</highlight></codeline>
<codeline lineno="342"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="343"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>got_aggregation_input<sp/>=<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">;</highlight></codeline>
<codeline lineno="344"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="345"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>agg_ops_for_request.push_back(makeCudfAggregation(aggregation_types[i]));</highlight></codeline>
<codeline lineno="346"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>agg_out_indices.push_back(i);<sp/><sp/></highlight><highlight class="comment">//<sp/>this<sp/>is<sp/>to<sp/>know<sp/>what<sp/>is<sp/>the<sp/>desired<sp/>order<sp/>of<sp/>aggregations<sp/>output</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="347"><highlight class="normal"></highlight></codeline>
<codeline lineno="348"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>if<sp/>the<sp/>aggregation<sp/>was<sp/>given<sp/>an<sp/>alias<sp/>lets<sp/>use<sp/>it,<sp/>otherwise<sp/>we&apos;ll<sp/>name<sp/>it<sp/>based<sp/>on<sp/>the<sp/>aggregation<sp/>and<sp/>input</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="349"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation_column_assigned_aliases[i]<sp/>==<sp/></highlight><highlight class="stringliteral">&quot;&quot;</highlight><highlight class="normal">)<sp/>{</highlight></codeline>
<codeline lineno="350"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(aggregation_types[i]<sp/>==<sp/>AggregateKind::COUNT_ALL)<sp/>{<sp/><sp/></highlight><highlight class="comment">//<sp/>COUNT(*)<sp/>case</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="351"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>agg_output_column_names.push_back(</highlight><highlight class="stringliteral">&quot;COUNT(*)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="352"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="353"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(column_index<sp/>==<sp/>-1){</highlight></codeline>
<codeline lineno="354"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>agg_output_column_names.push_back(aggregator_to_string(aggregation_types[i])<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>+<sp/>expression<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="355"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="356"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>agg_output_column_names.push_back(aggregator_to_string(aggregation_types[i])<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;(&quot;</highlight><highlight class="normal"><sp/>+<sp/>table.names().at(column_index)<sp/>+<sp/></highlight><highlight class="stringliteral">&quot;)&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline lineno="357"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="358"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="359"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="360"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>agg_output_column_names.push_back(aggregation_column_assigned_aliases[i]);</highlight></codeline>
<codeline lineno="361"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="362"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="363"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="364"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>requests.push_back(cudf::groupby::aggregation_request<sp/>{.values<sp/>=<sp/>aggregation_input,<sp/>.aggregations<sp/>=<sp/>std::move(agg_ops_for_request)});</highlight></codeline>
<codeline lineno="365"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="366"><highlight class="normal"></highlight></codeline>
<codeline lineno="367"><highlight class="normal"><sp/><sp/><sp/><sp/>CudfTableView<sp/>keys<sp/>=<sp/>table.view().select(group_column_indices);</highlight></codeline>
<codeline lineno="368"><highlight class="normal"><sp/><sp/><sp/><sp/>cudf::groupby::groupby<sp/>group_by_obj(keys,<sp/>cudf::null_policy::INCLUDE);</highlight></codeline>
<codeline lineno="369"><highlight class="normal"><sp/><sp/><sp/><sp/>std::pair&lt;std::unique_ptr&lt;cudf::table&gt;,<sp/>std::vector&lt;cudf::groupby::aggregation_result&gt;&gt;<sp/>result<sp/>=<sp/>group_by_obj.aggregate(<sp/>requests<sp/>);</highlight></codeline>
<codeline lineno="370"><highlight class="normal"></highlight></codeline>
<codeline lineno="371"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>output<sp/>table<sp/>is<sp/>grouped<sp/>columns<sp/>and<sp/>then<sp/>aggregated<sp/>columns</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="372"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;<sp/>std::unique_ptr&lt;cudf::column&gt;<sp/>&gt;<sp/>output_columns<sp/>=<sp/>result.first-&gt;release();</highlight></codeline>
<codeline lineno="373"><highlight class="normal"><sp/><sp/><sp/><sp/>output_columns.resize(agg_out_indices.size()<sp/>+<sp/>group_column_indices.size());</highlight></codeline>
<codeline lineno="374"><highlight class="normal"></highlight></codeline>
<codeline lineno="375"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>lets<sp/>collect<sp/>all<sp/>the<sp/>aggregated<sp/>results<sp/>from<sp/>the<sp/>results<sp/>structure<sp/>and<sp/>then<sp/>add<sp/>them<sp/>to<sp/>output_columns</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="376"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;<sp/>std::unique_ptr&lt;cudf::column&gt;<sp/>&gt;<sp/>agg_cols_out;</highlight></codeline>
<codeline lineno="377"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>result.second.size();<sp/>i++){</highlight></codeline>
<codeline lineno="378"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>j<sp/>=<sp/>0;<sp/>j<sp/>&lt;<sp/>result.second[i].results.size();<sp/>j++){</highlight></codeline>
<codeline lineno="379"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>agg_cols_out.emplace_back(std::move(result.second[i].results[j]));</highlight></codeline>
<codeline lineno="380"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="381"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="382"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>agg_out_indices.size();<sp/>i++){</highlight></codeline>
<codeline lineno="383"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(aggregation_types[agg_out_indices[i]]<sp/>==<sp/>AggregateKind::SUM0<sp/>&amp;&amp;<sp/>agg_cols_out[i]-&gt;null_count()<sp/>&gt;<sp/>0){</highlight></codeline>
<codeline lineno="384"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::unique_ptr&lt;cudf::scalar&gt;<sp/>scalar<sp/>=<sp/>get_scalar_from_string(</highlight><highlight class="stringliteral">&quot;0&quot;</highlight><highlight class="normal">,<sp/>agg_cols_out[i]-&gt;type());<sp/></highlight><highlight class="comment">//<sp/>this<sp/>does<sp/>not<sp/>need<sp/>to<sp/>be<sp/>from<sp/>a<sp/>string,<sp/>but<sp/>this<sp/>is<sp/>a<sp/>convenient<sp/>way<sp/>to<sp/>make<sp/>the<sp/>scalar<sp/>i<sp/>need</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="385"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>std::unique_ptr&lt;cudf::column&gt;<sp/>temp<sp/>=<sp/>cudf::replace_nulls(agg_cols_out[i]-&gt;view(),<sp/>*scalar<sp/>);</highlight></codeline>
<codeline lineno="386"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_columns[agg_out_indices[i]<sp/>+<sp/>group_column_indices.size()]<sp/>=<sp/>std::move(temp);</highlight></codeline>
<codeline lineno="387"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline lineno="388"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_columns[agg_out_indices[i]<sp/>+<sp/>group_column_indices.size()]<sp/>=<sp/>std::move(agg_cols_out[i]);</highlight></codeline>
<codeline lineno="389"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="390"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="391"><highlight class="normal"><sp/><sp/><sp/><sp/>std::unique_ptr&lt;CudfTable&gt;<sp/>output_table<sp/>=<sp/>std::make_unique&lt;CudfTable&gt;(std::move(output_columns));</highlight></codeline>
<codeline lineno="392"><highlight class="normal"></highlight></codeline>
<codeline lineno="393"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>lets<sp/>put<sp/>together<sp/>the<sp/>output<sp/>names</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="394"><highlight class="normal"><sp/><sp/><sp/><sp/>std::vector&lt;std::string&gt;<sp/>output_names;</highlight></codeline>
<codeline lineno="395"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>group_column_indices.size();<sp/>i++){</highlight></codeline>
<codeline lineno="396"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_names.push_back(table.names()[group_column_indices[i]]);</highlight></codeline>
<codeline lineno="397"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="398"><highlight class="normal"><sp/><sp/><sp/><sp/>output_names.resize(agg_out_indices.size()<sp/>+<sp/>group_column_indices.size());</highlight></codeline>
<codeline lineno="399"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i<sp/>=<sp/>0;<sp/>i<sp/>&lt;<sp/>agg_out_indices.size();<sp/>i++){</highlight></codeline>
<codeline lineno="400"><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>output_names[agg_out_indices[i]<sp/>+<sp/>group_column_indices.size()]<sp/>=<sp/>agg_output_column_names[i];</highlight></codeline>
<codeline lineno="401"><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline lineno="402"><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>std::make_unique&lt;BlazingTable&gt;(std::move(output_table),<sp/>output_names);</highlight></codeline>
<codeline lineno="403"><highlight class="normal">}</highlight></codeline>
<codeline lineno="404"><highlight class="normal"></highlight></codeline>
<codeline lineno="405"><highlight class="normal">}<sp/><sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>operators</highlight><highlight class="normal"></highlight></codeline>
<codeline lineno="406"><highlight class="normal">}<sp/><sp/></highlight><highlight class="comment">//<sp/>namespace<sp/>ral</highlight><highlight class="normal"></highlight></codeline>
    </programlisting>
    <location file="/home/tom/Documents/programming/romulo_blazingsql/blazingsql/engine/src/operators/GroupBy.cpp"/>
  </compounddef>
</doxygen>
