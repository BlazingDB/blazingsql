
#include <map>
#include <vector>

#include "protocols.hpp"
#include "messageReceiver.hpp"

#include <ucp/api/ucp.h>
#include <ucp/api/ucp_def.h>

#include "execution_graph/logic_controllers/CacheMachine.h"

namespace comm {

ucp_nodes_info & ucp_nodes_info::getInstance() {
	static ucp_nodes_info instance;
	return instance;
}

void ucp_nodes_info::init(const std::map<std::string, node> & nodes_map) {
	_id_to_node_info_map = nodes_map;
}

node ucp_nodes_info::get_node(const std::string& id) { return _id_to_node_info_map.at(id); }


/**
 * A struct that lets us access the request that the end points ucx-py generates.
 */
struct ucx_request {
	//!!!!!!!!!!! do not modify this struct this has to match what is found in
	// https://github.com/rapidsai/ucx-py/blob/branch-0.15/ucp/_libs/ucx_api.pyx
	// Make sure to check on the latest branch !!!!!!!!!!!!!!!!!!!!!!!!!!!
	int completed; /**< Completion flag that we do not use. */
	int uid;	   /**< We store a map of request uid ==> buffer_transport to manage completion of send */
};

enum class status_code {
	INVALID = -1,
	OK = 1,
	ERROR = 0
};

// TODO: remove this hack when we can modify the ucx_request
// object so we cna send in our c++ callback via the request
std::map<int, ucx_buffer_transport *> message_uid_to_buffer_transport;

std::map<void *, std::shared_ptr<status_code>> recv_begin_ack_status_map;


void send_begin_callback_c(void * request, ucs_status_t status) {
	auto blazing_request = reinterpret_cast<ucx_request *>(request);
	auto transport = message_uid_to_buffer_transport[blazing_request->uid];
	transport->recv_begin_transmission_ack();
	ucp_request_release(request);
}

void recv_begin_ack_callback_c(void * request, ucs_status_t status, ucp_tag_recv_info_t * info) {
	std::shared_ptr<status_code> status_begin_ack = recv_begin_ack_status_map[request];
	if (*status_begin_ack == status_code::OK) {
		auto blazing_request = reinterpret_cast<ucx_request *>(request);
		auto transport = message_uid_to_buffer_transport[blazing_request->uid];
		transport->increment_begin_transmission();
	}

	recv_begin_ack_status_map.erase(request);

	ucp_request_release(request);
}

void send_callback_c(void * request, ucs_status_t status) {
	auto blazing_request = reinterpret_cast<ucx_request *>(request);
	auto transport = message_uid_to_buffer_transport[blazing_request->uid];
	transport->increment_frame_transmission();
	ucp_request_release(request);
}


ucx_buffer_transport::ucx_buffer_transport(node origin_node,
    std::vector<node> destinations,
	ral::cache::MetadataDictionary metadata,
	std::vector<size_t> buffer_sizes,
	std::vector<blazingdb::transport::ColumnTransport> column_transports)
	: buffer_transport(metadata, buffer_sizes, column_transports), transmitted_begin_frames(0), transmitted_frames(0),
	  origin_node(origin_node), destinations{destinations} {
	tag = generate_message_tag();
}

ucx_buffer_transport::~ucx_buffer_transport() {
	message_uid_to_buffer_transport.erase(this->message_id);
}

/**
 * A struct for managing the 64 bit tag that ucx uses
 * This allow us to make a value that is stored in 8 bytes
 */
struct blazing_ucp_tag {
	int message_id;			   /**< The message id which is generated by a global atomic*/
	uint16_t worker_origin_id; /**< The id to make sure each tag is unique */
	uint16_t frame_id;		   /**< The id of the frame being sent. 0 for being_transmission*/
};

std::atomic<int> message_id(0);

ucp_tag_t ucx_buffer_transport::generate_message_tag() {

	blazing_ucp_tag blazing_tag = {message_id.fetch_add(1), origin_node.index(), 0u};
	message_uid_to_buffer_transport[blazing_tag.message_id] = this;
	this->message_id = blazing_tag.message_id;
	return *reinterpret_cast<ucp_tag_t *>(&blazing_tag);
}

void ucx_buffer_transport::send_begin_transmission() {
	std::vector<char> buffer_to_send = make_begin_transmission();

	std::vector<ucs_status_ptr_t> requests;
	for(auto const & node : destinations) {
		requests.push_back(ucp_tag_send_nb(
			node.get_ucp_endpoint(), buffer_to_send.data(), buffer_to_send.size(), ucp_dt_make_contig(1), tag, send_begin_callback_c));
	}

	for(auto & request : requests) {
		if(UCS_PTR_IS_ERR(request)) {
			// TODO: decide how to do cleanup i think we just throw an initialization exception
		} else if(UCS_PTR_STATUS(request) == UCS_OK) {
			send_begin_callback_c(request,UCS_OK);
		} else {
			// Message was not completed we set the uid for the callback
			auto blazing_request = reinterpret_cast<ucx_request *>(&request);
			blazing_request->uid = reinterpret_cast<blazing_ucp_tag *>(&tag)->message_id;
		}
	}
	// TODO: call ucp_worker_progress here
	wait_for_begin_transmission();
}

void ucx_buffer_transport::increment_frame_transmission() {
	transmitted_frames++;
	completion_condition_variable.notify_all();
}

void ucx_buffer_transport::increment_begin_transmission() {
	transmitted_begin_frames++;
	completion_condition_variable.notify_all();
}

void ucx_buffer_transport::wait_for_begin_transmission() {
	std::unique_lock<std::mutex> lock(mutex);
	completion_condition_variable.wait(lock, [this] {
		if(transmitted_begin_frames >= destinations.size()) {
			return true;
		} else {
			return false;
		}
	});
}

void ucx_buffer_transport::recv_begin_transmission_ack() {
	auto recv_begin_status = std::make_shared<status_code>(status_code::INVALID);
	std::shared_ptr<ucp_tag_recv_info_t> info_tag = std::make_shared<ucp_tag_recv_info_t>();
	blazing_ucp_tag acknowledge_tag = *reinterpret_cast<blazing_ucp_tag *>(&tag);
	acknowledge_tag.frame_id = 0xFFFF;
	ucp_worker_h ucp_worker = origin_node.get_ucp_worker();

	for(;;) {
		auto message_tag = ucp_tag_probe_nb(ucp_worker, acknowledge_tag, acknownledge_tag_mask, 1, info_tag.get());
		auto request = ucp_tag_msg_recv_nb(ucp_worker,
																			recv_begin_status.get(),
																			info_tag->length,
																			ucp_dt_make_contig(1),
																			message_tag,
																			recv_begin_ack_callback_c);
		recv_begin_ack_status_map[request] = recv_begin_status;

		if(UCS_PTR_IS_ERR(request)) {
			// TODO: decide how to do cleanup i think we just throw an initialization exception
		} else if(UCS_PTR_STATUS(request) == UCS_OK) {
			recv_begin_ack_callback_c(request, UCS_OK, info_tag.get());
			break;
		} else(ucp_worker_progress(ucp_worker)) {
				//waits until a message event occurs
				auto status = ucp_worker_wait(ucp_worker);
				if (status == UCS_OK) {
					break;
				} else {
					throw ::std::exception()
				}
		}
	}
}

void ucx_buffer_transport::wait_until_complete() {
	std::unique_lock<std::mutex> lock(mutex);
	completion_condition_variable.wait(lock, [this] {
		if(transmitted_frames >= (buffer_sizes.size() * destinations.size())) {
			return true;
		} else {
			return false;
		}
	});
}

void ucx_buffer_transport::send_impl(const char * buffer, size_t buffer_size) {
	std::vector<ucs_status_ptr_t> requests;
	blazing_ucp_tag blazing_tag = *reinterpret_cast<blazing_ucp_tag *>(&tag);
	blazing_tag.frame_id = buffer_sent + 1;	 // 0th position is for the begin_message
	for(auto const & node : destinations) {
		requests.push_back(ucp_tag_send_nb(node.get_ucp_endpoint(),
			buffer,
			buffer_size,
			ucp_dt_make_contig(1),
			*reinterpret_cast<ucp_tag_t *>(&blazing_tag),
			send_callback_c));
	}

	for(auto & request : requests) {
		if(UCS_PTR_IS_ERR(request)) {
			// TODO: decide how to do cleanup i think we just throw an initialization exception
		} else if(UCS_PTR_STATUS(request) == UCS_OK) {
			send_callback_c(request,UCS_OK);
		} else {
			// Message was not completed we set the uid for the callback
			auto blazing_request = reinterpret_cast<ucx_request *>(&request);
			blazing_request->uid = reinterpret_cast<blazing_ucp_tag *>(&tag)->message_id;
		}
	}
	// TODO: call ucp_worker_progress here
}

ucx_message_listener::ucx_message_listener(ucp_worker_h worker) :
    worker(worker) {

}

std::map<void *,std::shared_ptr<status_code> > status_scope_holder;

void send_aknowledge_callback_c(void * request, ucs_status_t status){
	status_scope_holder.erase(request);
	ucp_request_release(request);
}

void recv_begin_callback_c(void * request, ucs_status_t status,
							ucp_tag_recv_info_t *info) {
	auto blazing_request = reinterpret_cast<ucx_request *>(request);
	auto buffer = tag_to_begin_buffer_and_info.at(info->sender_tag).first;
	auto metadata_and_transports = detail::get_metadata_and_transports_from_bytes(buffer);
	auto metadata = metadata_and_transports.first;

	auto receiver = std::make_shared<message_receiver>(
		metadata_and_transports.second,
		metadata,
		metadata[ral::cache::ADD_TO_SPECIFIC_CACHE_METADATA_LABEL] == "true" ? nullptr : nullptr);
	//TODO: if its a specific cache get that cache adn put it here else put the general iput cache from the graph
	auto node = ucp_nodes_info::getInstance().get_node(metadata[ral::cache::SENDER_WORKER_ID_METADATA_LABEL]);
	auto acknowledge_tag = reinterpret_cast<blazing_ucp_tag *>(&info->sender_tag);
	acknowledge_tag->frame_id = 0xFFFF;
	auto acknowledge_tag_ucp = *reinterpret_cast<ucp_tag_t *>(&acknowledge_tag);

	auto status_acknowledge = std::make_shared<status_code>(1);
	auto request_acknowledge = ucp_tag_send_nb(
		node.get_ucp_endpoint(),
		status_acknowledge.get(),
		sizeof(status_code),
		ucp_dt_make_contig(1),
		acknowledge_tag_ucp,
		send_aknowledge_callback_c);

	if(UCS_PTR_IS_ERR(request_acknowledge)) {
		// TODO: decide how to do cleanup i think we just throw an initialization exception
	} else if(UCS_PTR_STATUS(request_acknowledge) == UCS_OK) {
		send_aknowledge_callback_c(request_acknowledge, UCS_OK);
	}
	status_scope_holder[request_acknowledge] = status_acknowledge;
	tag_to_begin_buffer_and_info.erase(info->sender_tag);
}

std::map<ucp_tag_t, std::pair<std::vector<char>, std::shared_ptr<ucp_tag_recv_info_t>>> tag_to_begin_buffer_and_info;


void ucx_message_listener::poll_begin_message_tag(ucp_tag_t tag){
    for(;;){
        std::shared_ptr<ucp_tag_recv_info_t> info_tag = std::make_shared<ucp_tag_recv_info_t>();
        auto message_tag = ucp_tag_probe_nb(
            ucp_worker, 0ull, begin_tag_mask, 1, info_tag.get());
        if(message != NULL){
            //we have a msg to process
			tag_to_begin_buffer_and_info[message_tag] = std::make_pair(
				std::vector<char>(info_tag->length), info_tag);
            auto request = ucp_tag_msg_recv_nb(ucp_worker,
				tag_to_begin_buffer_and_info[message_tag].first.data(),
				info_tag->length,
				ucp_dt_make_contig(1), message_tag,
				recv_begin_callback_c);



			if(UCS_PTR_IS_ERR(request)) {
				// TODO: decide how to do cleanup i think we just throw an initialization exception
			} else if(UCS_PTR_STATUS(request) == UCS_OK) {
				recv_begin_callback_c(request, UCS_OK, info_tag.get());
			}

        }else(ucp_worker_progress(ucp_worker)) {
            //waits until a message event occurs
            auto status = ucp_worker_wait(ucp_worker);
            if (status != UCS_OK){
                throw ::std::exception()
            }

        }



    }

}

}  // namespace comm
